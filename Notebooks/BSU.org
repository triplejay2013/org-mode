#+TITLE: BSU
#+AUTHOR: Justin Johnson

*BOLD*
_UNDERLINE_
=VERBATIM=
~CODE~
/ITALIC/

* Spring2019 Registration Prep
** Required Courses
   | UF 200 | CS 361 | CS 441  | CS 453    | CS 471 |
   |--------+--------+---------+-----------+--------|
   | CS 481 | CS 488 | CS 421? | CS-HU 271 |        |
** Spring 2019 Plan
*** INPROGRESS Consult Advisor to finalize Spring schedule
	SCHEDULED: <2018-10-22 Mon 10:00>
	| Course    | Description                         | Credits | Instructors            |
	|-----------+-------------------------------------+---------+------------------------|
	| UF 200    | Foundations of Ethics and Diversity |       3 |                        |
	| CS 361    | Intro to Theory of Comp             |       3 |                        |
	| CS 441    | Computer Architecture               |       3 |                        |
	| CS 453    | Operating Systems                   |       3 | Shane Panter/Amit jain |
	| CS-HU 271 | Agile Developement                  |       1 |                        |
	| ***         | Work U                              |      3  |                        |
	| ^         | Total:                              |      13 |                        |
	#+TBLFM: $3=vsum(@2..@-1)
** Fall 2019 Plan
   | Course | Description          | Credit |
   |--------+----------------------+--------|
   | CS 471 | Software Engineering |      3 |
   | CS 421 | Algorithms           |      3 | **Covered by transfer?
   |        |                      |        | **Accel. Masters Courses?

* Misc Items
** INPROGRESS update src and exmp insertion to have more infor like headers and names when hot-keyed
** FIXED Syncthing f**d things up....so missing most of my homework and recent updates
* Need to know commands for emacs
** Quick Commands
	- C-x C-q to disable read-only buffer
	- C-c C-e to export selected (whole file default) to certain format
	- C-c s - auto insert source block
	- C-x C-c to exit file
	- *S-right or S-left - cycle list type or TODO header types*
	[[https://justin.abrah.ms/emacs/literate_programming.html][Literate Programming]]
	- C-c C-v C-t  Tangle a code src block 
** Agendas
   -C-c a (t)
   	- opens up agenda view, compiles todo list with t option
	  - press t again to cycle TODOs
	  - "N r" means "1 r" to recompile list with specific keywords
	- (n)ext (p)revious
	- RET go to location of item and delete other windows
	- TAB go to location but keep current windows open
	- (f)orward or (b)ackward in time
	- '.' today
	- (j)ump prompt for date and go there
	- and more! Start practicing!

[[http://sachachua.com/blog/2007/12/emacs-getting-things-done-with-org-basic/][Agenda tips]]

* Accelerated Masters Application
  SCHEDULED: <2018-10-20 Sat> DEADLINE: <2018-12-08 Sat>

  [[http://coen.boisestate.edu/cs/undergraduates/accelerated-ms-cs/][Program Info]]

** TODO Print off application
   SCHEDULED: <2018-10-20 Sat>
** DONE Look at graduate Catalog
** TODO Contact and meet with falculty
   SCHEDULED: <2018-10-18 Thu>
	- [ ] Ask them what projects I might participate in that field of study
	- [ ] what courses I should take if I pursue their emphasis
*** Research areas of interest (in decsending order of interest)
	*REF:* [[http://coen.boisestate.edu/cs/researchareas/][Research areas of interest]]
	- *Software engineering*?
	  - Jim Buffenbarger
		- [[https://jimbuffenbarger.youcanbook.me/][book]]
		- email first? Then book meeting
	- *Bioinformatics*
	  - No falculty advisor
	- *Artificial Intelligence*
	  - Casey Kennington
		- [[https://caseykennington.youcanbook.me/][book]]
		- email first, then book?
	  - Tim Andersen (Artificial Neural Networks)
		- [[https://timandersen.youcanbook.me/][book]]
	- *Machine Learning*
	  - Casey Kennington
	  - Tim Andersen
		- Contact Casey first, then tim?

** TODO Spring Semester Planning
   SCHEDULED: <2018-10-20 Sat>
* Fall 2018
** ECE330
*** Assignments
**** SUBMITTED Lesson 13 - Ch. 12 Problems (all)
     DEADLINE: <2018-10-02 Tue>
**** SUBMITTED Quiz - Ch. 12 OpenNote OpenBook
	 DEADLINE: <2018-10-02 Tue 18:00>
**** SUBMITTED Lesson 15 - Ch. 14 Problems (all)
	 SCHEDULED: <2018-10-08 Mon> DEADLINE: <2018-10-09 Tue>
**** SUBMITTED Lesson 17 - Ch. 15, 16 Problems (all)
	 DEADLINE: <2018-10-16 Tue> SCHEDULED: <2018-10-15 Mon>
**** CANCELED Prelecture read and review
	 DEADLINE: <2018-10-16 Tue> SCHEDULED: <2018-10-15 Mon>
**** TODO Take Home QUIZ (ADC, interrupts)
	 DEADLINE: <2018-10-24 Wed> SCHEDULED: <2018-10-23 Tue>
**** TODO Study for exam 2
	 SCHEDULED: <2018-10-24 Wed>
	 - [0/6] Create Note Sheet with the following information
	   - [ ] Reef polling review
	   - [ ] Look through lecture (you should understand) bullets
	   - [ ] Bit manipulation (putbit, getbit)
		 - [ ] See notes on topic for comprehensive overview
	   - [ ] Read through chapter summaries
	   - [ ] ADC calculations
	   - [ ] Include relevant notes from prior exam notesheet
*** Lecture
**** Directives
	 - .org ###
	   - Use up ### bytes of memory. 'Skips' ### for the location counter
**** Bit Manipulation
***** Notes
****** Abstractions
 *These abstractions can be implemented with simple Bitwise operations*
 1. Test Bit
	find what bit (?) is in a location
 2. Set Bit
	makes a bit a '1'
 3. Clear Bit
	makes a bit a '0'
 4. Toggle Bit
	1->0, 0->1
 5. Get Bit(s)
 6. Put Bit(s)

****** Register Represenation and truth tables
******* Mask Register
	 					        															 - BOI (bit of interest, SIZE =1
																							 V
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
 |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  B |    |    |    |   |   |   |   |   |   |   |   |   |   |
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
																										 *OFFSET (from bits 0-12)*

******* Truth Tables
  - And (Effectively 'Test Bit' & 'Clear Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |---|_ Clear Bit
	| 0 | 1 | 0 |---|
	| 1 | 0 | 0 |---|_ Test Bit
	| 1 | 1 | 1 |---|

  - OR (Effectively 'Set Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |
	| 0 | 1 | 1 |
	| 1 | 0 | 1 |---|_ Set Bit
	| 1 | 1 | 1 |---|

  - EOR (Effectively 'Toggle Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |
	| 0 | 1 | 1 |
	| 1 | 0 | 1 |---|_ Toggle Bit
	| 1 | 1 | 0 |---|
   
******* Expr and Instr
 |                             | and | or   | eor | not | shift-left | shift-right |              |
 |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
 | assembly time mask          | &   | pipe | ^   | ~   | <<         | >>          | expressioins |
 |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
 | Target operation (run time) | and | orr  | eor | mvn | lsl        | lsr         | instructions |
****** Mask/Inverse Mask
		- A mask is a filter that allows us to focus on BOI (Bit of Interest)
		- Values from some register we want to retrieve bits from, are copied into a mask register
		- Represent bits (example from book)
			- ldr r4, =0b00000000000000100000000000000000000 (not counted) //too lengthy
			- ldr r4, =0x00400000 //a little intuitive
			- ldr r4, =4194304 //unclear, don't use
			- ldr r4, =(1<<22) //intuitive which bit we are considering
		- *Mask* - all bits but the BOI are '0'
		- *Inverse mask* = all bits but the BOI are '1'
#+BEGIN_EXAMPLE 
1 << 12
12: acts like the 'offset' for the data
0b111 << 12: sets bits 12, 13, and 14 to 1

~0 << 3: 11111000

Normalize-Denormalize
Static mask
~(~0 << 3) << 12
		|      |_
		V	     V
    sizeInBits  offset
#+END_EXAMPLE
****** Put and Get Bit
		+ Get Bit(s) - AND mask can get the BOIs
		+ Put Bit(s) - takes as input, a bit value (0 or 1). Takes value at runtime and puts into position
******* Normalize
******* De-Normalize
****** Normalize/Denormalize
	   Normalize - Shift bits /aligned right/
	   Denormalize - Shift bits to desired location
***** Examples
****** Bit Manipulation Abstractions
#+BEGIN_EXAMPLE
# testbit(boi=14)
ldr r4,=0x12345678		//0x12345678 - target
ldr r2,=(1<<14)			//r2: 0x00004000 - mask
and r2,r4,r2			//r2: 0x12345678 - apply mask

#setbit(boi=15)
ldr r4, =0x12345678		//r4: 0x12345678
ldr r2,=(1<<15)			//r2: 0x00008000 - create mask
orr r2,r4,r2			//r2: 0x12345678 - apply mask
.
.
.
Check Blackboard for more examples pdf file in this directory
#+END_EXAMPLE
[[file:resources/BitManipulationAbstractions.pdf][More Examples Here]]
**** Mutator and Accessor
***** Definitions
| get | Accessor | function that retrieves a value from a private member variable                                                                |   |
|-----+----------+-------------------------------------------------------------------------------------------------------------------------------+---|
| set | Mutator  | a member function that stores a value in a private member variable, or changes its value in some way (setLength and setWidth) |   |

*IMPORTANT* Accessors do not change an object's data, so they
should be marked ~const~ (getLength and getWidth)

**** Pointers and Arrays in Assembly
***** Pointers

[[https://emacs.stackexchange.com/questions/9612/does-org-mode-has-a-assembly-highlight][Assembly Babel-support]]
#+NAME: Pointer Example
#+BEGIN_SRC asm
.text
// DEREFERENCING DATA
ldr r0,=A //est. addr. to var. A in r0
ldr r1,[r0,#0] // dereference data here

// DEREFERENCING POINTERS (3-step process)
ldr r0,=PA	// Load pointer
ldr r1,[r0] // Load address the pointer contains
ldr r2,[r1]	// use value at address referenced by PA
//===========
ldr r0,=PB
ldr r1,[r0]
ldrb r2,[r1]
//===========
ldr r0,=PC
ldr r1,[r0]
ldrb r2,[r1]

.data
A	.word	0x11111111
PA:	.word	A	# This is a pointer to A
B	.byte	0x11111111
PB:	.word	B	# This is a pointer to B
C	.short	0x11111111
PC:	.word	C	# This is a pointer to C
#+END_SRC
***** Arrays
#+NAME: Array example
#+BEGIN_SRC asm
.data
ARRAY1: 	.word	1,2,3,4,5,6,7,8
ARRAY_END: 	.word	1,2,3,4,5,6,7,8

.equ ARRAY_SIZE,
	(ARRAY_END - ARRAY1)/4 	// a word is 4 bytes, for each elment in the array. 
							//The size in bytes divided by 4 bytes gives us the size
#+END_SRC

#+NAME: Array examples ASCII
#+BEGIN_SRC asm
ARRAY1: 	.byte 	0x62, 0x72, 0x6F, 0x6E, 0x63,0x6F,0x73,0x00
ARRAY2: 	.byte 	'b','r','o','n','c','o','s','\0' //appending \0 makes a string
ARRAY3: 	.ascii	"broncos"
ARRAY4: 	.string	"broncos" 						//makes a string
ARRAY5: 	.asciz	"broncos"						//makes nul-terminated string
#+END_SRC
***** ASCII
	  - ASCII - American Standard Coding Information Interchange
****** TODO Put Ascii table on notecard for exam 2
**** ADC (Analog to Digital Converter, also see DAC)
***** TODO Read Prelecture slides
	  DEADLINE: <2018-10-16 Tue> SCHEDULED: <2018-10-16 Tue>
***** Notes
****** SAR (Successive Approximation Register)
	   - Fast ADC implmentation
		 - Uses binary search ( O(logn))
****** Graunularity/Resolution
	   - Number of bits to represent input/output
****** Equations (Memorize, or know when to use)
	   - Vres = (Vref)/2^n = Vlsb
		 - Vref (aka range: bits 0 to 4)
		 - n = num bits
		 - Voltage of least sig. bit
	   - ADC = floor((Vin * 2^n)/Vref) = floor(Vin/Vres)
		 - Vin is the input voltage (2.4v)
		 - outputs a count (in binary, ex: 2 is 010)
		   - This coun represents volume magnitutde (level)
	   - Vadc = ADC * Vres 
		 - Vin (analog input)
	   - Noise = Vin - Vadc 
**** Interrupts - Enabler for the Modern Computer (Operating System)
***** Exceptions
****** Interrupts
******* Hardware Interrupts
******* Software Interrupts
****** Faults
	   - Computer (program) crashes
** Math307
*** Lecture
**** RSA
***** Notes
****** Key Generation
Key Generation
 1. Choose two primes p,q and compute:
    n=p*q
    phi(n)=(p-1)*(q-1)
 2. Choose a 'random' number t such taht gcd(x,phi(n))=1
 3. Compute e=t^-1 mod phi(n) (t=e^-1 mod phi(n))
	
Public Key:		(n,e)
Private Key:	(t, phi(n))

*RSA ENCRYPTION*
E=M^e mod n
E=ciphertext of M

*RSA DECRYPTION*
M=E^t mod n

*MISC*
e=t^{-1} mod phi(n)
t=e^{-1} mod phi(n)
e is public
phi(n) is private

*FACTORING PROBLEM*
Given n that is a product of two primes, find its primes
****** Signatures
	   - Confidentiality
	   - Data integrity
	   - Authentication
	   - [[https://searchsecurity.techtarget.com/definition/nonrepudiation][Non-repudiation]]
		 - is the assurance that someone cannot deny something.
******* Define ownership of an RSA Key
		terse: signed with private key, verified with public key

		1. The key owner chooses two prime numbers, /p/ and /q/
		2. The key owner compute ~n=p*q~ and ~phi(n)=(p-1)*(q-1)~
		3. The key owner chooses an /e/ with ~gcd(e/phi(n))=1~
		   1. Compute ~e=t^-1 mod phi(n)~
		4. The key owner computes ~t=1/e mod phi(n)~
		
		[[./img/PhiEx.jpg][Whiteboard example]]
		
		The public signature key is ~(n,e)~ 
		The private signature key is ~t~

******* Verify Ownership
		- ~S=M^t mod n~
		  - S is a signature on M
		- ~k=S^e mod n~
		- If k=M, then the signature is valid
****** Attacks
******* COMMON MODULUS ATTACK
Suppose that same message M < n is sent to two different parties whose
encryption exponents respectiveily are e_1 and e_2 and suppose that gcd(e1,e2)=1

 - Assume gcd(e1,e2) = 1
 - gcd(a,b) = a*x + b*y
   for some x,y belonging to Z
 - Using the extendid Euclidean algorithm one can find x and y such that:
   1 = gcd(e1,e2)=e_1 * x + e_2 * y
 - The original message can be found by:
   E^x * F^y mod n 
   = ((M^{e_1} mod n)^x * (M^{e_2} mod n)^y) mod n
   = (M^{e_1})^x * (M^{e_2})^y mod n
   = M^{e_1 * x + e_2 * y} mod n 
   = M^1 mod n 
   = M

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

The encrypted messages are: 
E=M^{e_1} mod n  	(Alice)
 and 
F=M^{e_2} mod n		(Bob)

******* COMMON ENCRYPTION EXPONENT
/assume same people and messages as above/
Assume that gcd(n_1,n_2)=1
Plaintext:	M < n1,n2
E_1=M^e mod n_1	(Alice)
E_2=M^e mod n_2	(Bob)

Using CRT we can solve 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 for M.
 
 M is the unique solution of 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 modulo n1*n2
 	M mod n1*n2 = M because M <n1,n2

	*CHINESE REMAINDER THEOREM (CRT)*
	let n1, n2, ... , nk be natural numbers such that for i,j distinct incices one
	has gcd(ni,nj)=1

	then the system of linear congruences has a solution which is unique modulo:
		N=n1*n2*..*nk
		
    Solution: x=b1*N1*x1 + b2*N2*x2+...+bk*Nk*xk mod N
    where Ni=N/ni and xi=(1/Ni) mod ni
******* COMMON MODULUS ATTACK (Directory Attack?)

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

n1 != n2

If gcd(n1,n2) = d > 1
	this means that n1 and n2 share more than 1 factor (other than 1|N)
	then d is one of the primes of n1 *and* n2
******* DOUBLE DUTY ATTACK
		- Assume that /Alice/ uses the same RSA key for encryption AND signature
		- Knowing the same key is used for encryption and signature, we can decrypt the ciphertext E
		  1. Choose a random number /b/
		  2. Compute ~x=b^e * E mod n~
		  3. request /Alice? to sign x
		  4. Let /y/ be the signature on /x/. Compute ~y/b mod n~
		  5. claim y/b mod n = M

Proof of claim (5)
REMEMBER:
~e=t^-1 mod phi(n)~
~e*t = t*t^-1 mod phi(n)~
~e*t = 1 mod phi(n)~
~e*t mod phi(n) = 1~

~y/b mod n = (x^t)/b mod n~
		  ~= (b^e * E)/b mod n~
		  ~= ((b^{e*t})/b) * E^t mod n~
		  ~= ((b^{e*t mod phi(n))}/b) * E^t mod n~
		  see REMEMBER above
		  ~= (b^1)/b * E^t mod n~
		  ~= 1 * E^t mod n~
		  ~= E^t mod n = M~
******* Chosen Ciphertext Attack(Signature Forging)
		- This attack can be used to forge a signature on a message
******** M-coded message
		- Compute factorization of:
		M= p1^{m1} * p2^{m2}*...*pk^{mk}
		- Requests that bob sign p1,p2,p3,....,pk
		- Assume that Q1,Q2,Q3,...,Qk are corresponding signatures..
		CLAIM: Q1^{m1}*Q2^{m2}*....*Qk^{mk} is Bob's signature on M

		(n,e) - Bob's public signature key
		Q1=P1^t mod n (Q1 is a signature on p1)
		Q2=p2^t mod n
		.
		.
		.
		Qk=pk^t mod n : where t is Bob's private signature key

******** RSA verification:
			____SIGNATURE_____
		(Q1^{m1}*Q2^{m2}*....*Qk^{mk})^e mod n = M
		(Q1^{m1})^e *(Q2^{m2})^e *....* (Qk^{mk})^e mod n = M
		((P1^t mod n)^{m1*e}) *((P2^t mod n)^{m2*e}) *....* ((pk^t mod n){mk*e}) mod n = M
		(p1^{t*e})^m1 * (p2^{t*e}})^m2 *...* (pk^{t*e})^mk mod n
		REMEMBER: t=e^-1 mod phi(n) --> t*e= 1 mod phi(n)
		(p1^{t*e mod phi(n)})^m1 * (p2^{t*e mod phi(n)}})^m2 *...* (pk^{t*e mod phi(n)})^mk mod n
		(p1^1)^m1 * (p2^1)^m2 * ... * (pk^1)^mk = M
		^
		This shows that Q1^m1 * Q2^m2 *....*Qk^mk is a valid signature on M
#+NAME: CipherText worked out
#+BEGIN_EXAMPLE 
#+END_EXAMPLE
******** Example
#+BEGIN_EXAMPLE 
M=12=2^2 * 3
Bob's public signature key (n=15,e=7)

15=3*5, phi(15)=(3-1)(5-1)=12
t=7
e= t^-1 mod 8
e= 7^-1 mod 8
e=7

1. We will show how Eve can forge Bob's signature on M=12
2. Eve asks Bob to sign p1=2 and p2=3
3. Bob signs p1=2: 2^7 mod 15 = 8
4. Bob signs p2=3: 3^7 mod 15 = 12
   - 8 is Bob's signature on 2
   - 12 is Bob's signature on 3
5. Eve computes the following:
   - 8^2 * 12^1 mod 15 = 3
   - We claim that 3 is a valid signature on M
6. Too show this we need to use RSA verifiction algorithm
   - S = 3; a valid signature
   - if S^e mod n = M, S is a valid signature on M
   - Compute 3^7 mod 15 = 12 *Verified!


#+END_EXAMPLE
******* Fermat's Factoring Method
******** See Sage:fermatAttack.sagews for example
******** Attack
		- Theorem (Fermat) Every odd integer (positive)
		  can be represented as difference of squares
		  - n=X^2-y^2 = (x-y)(x+y)
		- Fermat's attack is a deterministic factoring method
		  - not probabilistic?
		- Assume that n is RSA modlus. This means
		  - p=x-y and q=x+y
		  - p+q = 2x -> x=(p+q)/2
		  - q-p = 2y -> y=(q-p)/2
		  - n = x^2 - y^2 -> y^2=x^2 -n
			- y^2 >= 0 implies x^2 >= n  implies x >= sqrt(n)
		- Method
		  1. x= floor(sqrt(n))
		  2. check floor(x)^2 - n is a perfect square
			 1. if yes, we are done
				1. sqrt(floor(x)^2 -n)) = y
				2. floor(sqrt(n))=x
			 2. if not x->x+1
				1. x=floor(sqrt(n))+1
				2. Check whether floor(x)^2 - n is a perfect square
				   1. If yes we are done.
				   2. Otherwise x->x+1 and repeat
******** Defence
		- find p*q=n such that Fermat's factoring method is computationally difficult
		- Misc
		  - x=sqrt(n) +1
		  - x^2 - n = y^2
		  - (sqrt(n) + 1)^2 -n = y^2 (?)
		  - .
		  - .
		  - .
		  - (sqrt(n) + m)^2 - n = y^2

		- Defence against
		  1. If we have {p=x-y; q=x+y}, x=(p+q)/2, y=(q-p)/2
		  2. Using simple algebra...we get
			 - m=(sqrt(p) - sqrt(q))^2 /4
		  3. m is "small" if p~=q
		  4. DEFENSE: Choose p and q such that m is "large"
		
********* Example
********** SAGE procedure on blackboard shows this defence
********** Misc
		  1. Assumee that after k many iterations we find
			 1. x=sqrt(n) +k and y=sqrt(x^2 -n)
******* Initial Segment Factoring Method
******** IS attack explained
		 - R - RSA modulus
		 - R has n digits
		 - Consider: ~x_j = (R-(Rmod 10^j))/10^j for j < n~
#+NAME: IS attack (proof)
#+BEGIN_EXAMPLE 
R=12351 //Number to find factors of
n=5 //Number of iterations

j=1 : x1 = (12351-(12351 mod 10))/10
REMEMBER: 12351 = 1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4
12351 mod 10 	= (1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4) mod 10
12351 mod 10 	= 1*10^0 mod 10 + 5*10^1 mod 10 
					+ 3*10^2 mod 10 + 2*10^3 mod 10 + 1*10^4 mod 10 
				= 1 + 0 + 0 + 0+ 0 = 1
x1				= (12351-1)/10 = 12350/10 = 1235
x1 is the first four digits of R

j=2 : x2 = (12351-(12351 mod 10^2))/10^2
REMEMBER: 12351 = 1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4
12351 mod 10 	= (1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4) mod 100
12351 mod 10 	= 1*10^0 mod 100 + 5*10^1 mod 100 
					+ 3*10^2 mod 100 + 2*10^3 mod 100 + 1*10^4 mod 100
				= 1 + 50 + 0 + 0+ 0 = 1
x2				= (12351-51)/10 = 12300/10 = 123
x2 is the first three digits of R

xj is the first n-j digits of R
Because R is the product of 2 primes, the first gcd > 1 will be a prime factor
for some j, gcd(R,xj) = q
#+END_EXAMPLE
******** Defence:
		 1. Check whether n is weak against Fermat Attack
			- n i sresistant against Fermat Attack
		 2. Choose primes p and q such that p has some number of
			consecutive zeroes and choose q such that #q is alrger than
			the number of zeroes in p
		 3. Compute N=p*q
		 4. Apply IsAttack on N and Fermat Attack on N
******* One Line Factoring and partial Key Exposure Attack (Similar to Fermat)
******** Method
		1. Compute s= ceil(sqrt(n))
		2. Compute m = s^2 mod n
		3. Check whether m is a perfect sqaure
		   - If yes, compute t= sqrt(n). then gcd(s-t,n)=p
		   - if not increase i and go to step 1
******** Analysis
		 - Assume that n=p*q has prim factors n^1/3 < p, q < n^2/3
		 - view Slides on own time to see the proof
		 - O(cube_root(n)) with probability greater than .5
******* Partial Key Exposure Attack
******** Attack
#+NAME: Why it works (Partial Key Exposure Attack Proof)
#+BEGIN_EXAMPLE 
Ex1:	
	5 = 2 mod 3
	5 = 1*3 + 2
Ex2:
	17 = 2 mod 3
	17 = 5*3 + 2
Ex3:
	d = e mod n
	d = n*k + e :for some k

d 	= 1/e mod phi(n)
d*e = 1 mod phi(n)
e*d	= k*phi(n) + 1
UNKNOWNS:	phi(n),k,d
KNOWNS:		n,e
"Well-Known" AM-GM inequality shows:
	2sqrt(xy) <= x + y
! This can be used to approximate phi(n)
	phi(n) 	= (p-1)(q-1)
			= pq - (p+q) + 1 <= pq - 2sqrt(pq) + 1
			<= n - 2sqrt(n) + 1
			*Note equality sign flipped by mult. of -1
	e*dk	= k*phi(n) + 1 //where Dk is smoe approximation of d (private key)
		therefore
	*For k < d define:
	Dk 		= (k*phi(n) + 1)/e //note that phi(n) is our approximation as shown above
	
	if we have the last m digits of d, (Least significant portion), we can
	substitute L (least significant portion) to improve our approximation
	of Dk by replacing the LSD (Least Significant Digits) of Dk with L.
	
#+END_EXAMPLE

#+NAME:  Partial Key Exposure Attack
#+BEGIN_SRC sage
########################################################################################
# The function takes in the requested inputs and computes a decryption key             #
# If there are not enough digits in the input the function will tell you so            #
########################################################################################

def partial (R, e, partd):
    m = 1000
    E = m.powermod(e,R)#&^(m, s) % R
    for k in range(1, e * 10000):
        Dk = math.floor((k * (R - 2 * isqrt(R) + 1) + 1) / e)
        l=(partd).ndigits()
        Dk=Dk-(Dk % 10^l)+partd
        mm = E.powermod(Dk,R)#E&^Dk mod R:
        if m == mm:
            return(Dk)
    print("not enough digits to discover d")

R=1030794365305576815134103206958049837943419896523;
e=17873;
partd=6816907735531628355014100526810177;
Dd=partial(R,e,partd);
Dd

p = next_prime(776213649127364987123648972364987123648972316498623197124356715324065713526)
q = next_prime(2345545654565456654512374619287364981723648972163984612983461912386)
N = p*q
phiN = (p-1)*(q-1)
e = 17
e
while gcd(e,phiN)!=1: e+=1
d = 1/e % phiN
d
partialD = 1452930806742028080905133750698038297318124171383735131021465946217038961017925194270324213877445652376073
Dd=partial(N,e,partialD);
Dd
#+END_SRC

#+RESULTS: Partial Key Exposure Attack
: not enough digits to discover d
: 17
: 749677168357388769334958802538629561452930806742028080905133750698038297318124171383735131021465946217038961017925194270324213877445652376073
: not enough digits to discover d

******** Defence
		 - Retain MSD (Most significant digit)
		 - Split into different ways (every other digit, every 3rd digit)
		 - Split into several parts
***** Examples
****** Attacks:COMMON MODULUS ATTACK (Directory ATTACK?)
From Sage:
#+BEGIN_SRC python

# an example of rsa common modulos attack
# (1) Choose three large primes
p=next_prime(16718273096520398462809571209865120938651029871098236409287109865983649721650123640975210352)
q1=next_prime(1092836510928346091832650987120398470239861059836018923750892136509812349086230985709128349)
q2=next_prime(1230519283509213864092710983561209836590218364921836509827340892370561029309871423498021350)
# (2) Compute n1=p*q1
#             n2=p*q2
n1=p*q1
n2=p*q2
# (3) Computer phi1=(p-1)*(q1-1)
#              phi2=(p-1)*(q2-1)
phi1=(p-1)*(q1-1)
phi2=(p-1)*(q2-1)
# (4) Choose two random numbers t1, t2 such that:
#                 gcd(t1,phi1)?=1
#                 gcd(t2,phi2)?=1
t1,t2=31,next_prime(1024)
while(gcd(t1,phi1)!=1):
    ++t1
while(gcd(t2,phi1)!=1):
    ++t2
# (5) Compute:
#      t1^-1 mod phi1
#      t2^-1 mod phi2
d1=inverse_mod(t1, phi1)
d2=inverse_mod(t2,phi2)

#Directory Attack:
x=xgcd(n1,n2)
print(x[0]) #Calculated prime gcd(n1,n2)=p
print(p)    #Original prime

#+END_SRC
****** ATTACKS: ISATTACK
#+NAME: InitialSegment Attack Small q
#+BEGIN_SRC sage
def ISAttack (R):
    n = R.ndigits()
    #n = len(R)
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"

# Choose large prime with many consecutive zeros
p=next_prime(1213000000000000000000000000000000000000000000000000000000000000124)
p
# Choose prime with less digits than p has zeros
q=next_prime(1234567890)
q
# COmputer n=p*q
n=p*q
n
# Apply ISAttack
p=ISAttack(n)
p
#+END_SRC
#+RESULTS: InitialSegment Attack
: 1213000000000000000000000000000000000000000000000000000000000000291
: 1234567891
: 1497530851783000000000000000000000000000000000000000000000000000359259256281
: 1234567891

#+NAME: InitialSegment Large q
#+BEGIN_SRC sage
def ISAttack (R):
    n = R.ndigits()
    #n = len(R)
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"

# Choose large prime p with many consecutive zeros
p=next_prime(1000000000000000000000000000002347239472938749237492837498237984237987237498792831)
p
# Choose large q
q=next_prime(196327349823794238791247612374689213649218736498)
q
# Compute n=p*q
n=p*q
n
p=ISAttack(n)
p
#+END_SRC
#+RESULTS: InitialSegment Large q
: 1000000000000000000000000000002347239472938749237492837498237984237987237498793079
: 196327349823794238791247612374689213649218736623
: 196327349823794238791247612375150040954342600855043086369924757982661461133718474657040466537331025478920476913721120235676232217
: nonefound

**** Iterated Encryption
***** Iterated encryption security
#+BEGIN_EXAMPLE 
E1=M^e mod n
E2=E1^e mod n
E3=E2^e mod n
E4=E3^e mod n
.
.
.
Ek-1=E(k-2)^e mod n
Ek=E(k-1)^e mod n


BUT....
Ek			=	((E(k02)^e)^e mod n) mod n
			=	(E(k-2)^e^2) mod n
			=	(E((k-3)^e)^e^2) mod n
			=	(E(k-3)^e^3) mod n
			.
			.
			=	(E1^e^(k-1)) mod n
			=	((M^e)^e^(k-1)) mod n
			=	(M^e^(k)) mod n
#+END_EXAMPLE
***** Euler's Theorem
	  - m<n , gcd(m,n)=1
	  - m^phi(n)  mod n = 1
***** Fermat's Theorem
#+BEGIN_EXAMPLE 
Ek	=M^e^k mod n
	=M^(e^k mod phi(n)) mod n

if e^k mod phi(n) = 1, then
Ek = M
#+END_EXAMPLE
***** Carmichael Function
	  - lambda(n) is the smallest integer m such that a^m _= 1 mod n
	  - if n is > 0, and a is pos int coprime to n then a^lambda(n) mod n = 1
#+BEGIN_EXAMPLE 
Ek = M^e^k mod n
e^k mod lambda(n) = 1
:e^k = t * lambda(n) + 1

Example: 	5 mod 3 = 2
			5 = 1*3 + 2
Example: 	7 mod 3 = 1
			7 = 2*3 + 1
e^k 	= t * lambda(n) +1
M^e^k	= M^t*lambda(n) + 1 mod n
		= M^t*lambda(n) * M) mod n
		= ((M^lambda(n))^t mod n) * M mod n
			^^
		 1^t (carmichael's thm)
		= M
#+END_EXAMPLE
*** In-Class Examples/Practice
#+NAME: Iterated Encryption
#+BEGIN_SRC sage

# RSA - Encryption Procedures=========
def rsaencrypt(Message, encrexp, encrmod, rounds):
    if (rounds <= 0): return Message
    A=Message
    E = power_mod(A,encrexp,encrmod);
    return rsaencrypt(E,encrexp,encrmod, rounds-1)
#=====================================

# Blackboard:LectureNotes:Lecture11:Example
# REMEMBER: E1=M^e mod n
# Where M-plaintext and E-ciphertext
# ^^ 1st encryption vv 2nd encryption
# E2=E1^e mod n

# Encryption Modulus:
n=315562173921131111550753275258954314886929684614433857059068225329589007516900986203500713113234143069878550293
# Encryption Exponent:
e=1835588100642725811278316299646156385857628660058608776628872255463681001129596115865795858135978837517124882698892069345209251312769967638417909171551219459094621692202465346003400944724101186482909006146466321559204641
# Ciphertext:
E=150598315159426420417362370315760759643687452249127260593893330249875774660837569082216166241764228321707042114

E=rsaencrypt(E,e,n,10)
E
#+END_SRC

#+RESULTS: Iterated Encryption
: 150598315159426420417362370315760759643687452249127260593893330249875774660837569082216166241764228321707042114

*** Assignments
**** DONE Homework 4 [2/2]
     DEADLINE: <2018-10-03 Wed 11:16>

	 - [X] part 1
       - Describe how I found my solutions. Place answers in document
	 - [X] part 2
       - Place code for solving the two parts here

**** DONE Homework 6
	 DEADLINE: <2018-10-18 Thu> SCHEDULED: <2018-10-15 Mon>
***** SUBMITTED Print off assignment
	  SCHEDULED: <2018-10-17 Wed> DEADLINE: <2018-10-18 Thu>
***** Solution
#+NAME: Assignment 6: Fermat Attack
#+BEGIN_SRC sage 
# Function Definitions
# REF: Blackboard Software (rsadecrypt)
def ASCIIDepad(Number):
    n = Number.ndigits() % 3;
    if (n > 0):
        print("This is not a padded ASCII string\n");
    else:
        L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
        N = "";
        for i in range(Number.ndigits()/3):
            N = chr(L[i]) + N;
        return(N)

def rsadecrypt(encr,decrexp,encrmod):
    D = power_mod(encr,decrexp,encrmod);
    N = ASCIIDepad(D);
    return(N);


# From Blackboard Software Sources (Fermat Attack)
def isqrt(n):
    return int(floor(sqrt(n)))

def usqrt (n):
    ur = isqrt(n)
    if ur ** 2 < n:
        ur = ur + 1
    return(ur)

def FermatAttack (n, rounds):
    st = usqrt(n)
    for x in range(st, st + rounds + 1):
        #print (x-st)
        sq = x ** 2 - n
        y = isqrt(sq)
        if y ** 2 == sq:
            print "Factor found in round {0}".format(x-st+1)
            return(x + y)
    print "No factor found in {0} rounds".format(rounds)

# Define Problem information into code
# aliceKey=(R/n,e) where R or n is the modulos
aliceKey=(3200909051105364201164693808053590029074088922158723491051061550603549823737458227601881401901569257978004143012923593331603179164497963879113975835000986070024699519343049991253001543465847139349037243656109687211847515003135028132545450689475582835433024130454351048493271288284326740872991312817737068756145723348616748658487242931184584005382638341 ,45938274932874982748938989492800101)
n=aliceKey[0]
e=aliceKey[1]
bobM=1646965299225077453528764533325484870128106736546137408200095456059067040313170132659677309326733627254170824177278689792967869683703210102631692715251241388457103568881887427174337319839702934337074114069079964028787201219122008132800911350242389943062437915595376659222211331548822861710469042657218207369516502014847384607200570429591504554077212313

# Try a Fermat Attack on bob's message
p=FermatAttack(n,10)
p
# Find the prime factors of n
q=aliceKey[0]/p
phi=(p-1)*(q-1)

# compute private key
t=inverse_mod(e,phi)
t
	
# Attempt to decrypt the message
D=rsadecrypt(bobM, t, n)
D

print("\nSolutions:\n")
print("The message is {}\n".format(D))
print("The private key is {}\n".format(t))
print("The value of phi(R) is {}\n".format(phi))
print("Factors of R are {} and {}\n".format(p,q))

#+END_SRC

#+RESULTS: Assignment 6: Fermat Attack
#+begin_example
Factor found in round 1
56576576876878687676755667454534349837593827932875983275983759382759287237567887987980908998787786767565645454533423423343243546576576876879879879879878687675765644535434287237L
3167863510034742237627997195928786583153512307937169989597828968058877017293250922100187347305076307004322384676497222811128113753424625921466939826882160195180303741752185273650841791717876895004244979963739993488694617994141773778317684342636200808646316120457410025841816142247504391080136501066088010574604519661347572707772349904352818684682371437
'Identity Based Cryptosystems'

Solutions:

The message is Identity Based Cryptosystems

The private key is 31678635100347422376279971959287865831535123079371699895978
289680588770172932509221001873473050763070043223846764972228111281137534246259
214669398268821601951803037417521852736508417917178768950042449799637399934886
946179941417737783176843426362008086463161204574100258418161422475043910801365
01066088010574604519661347572707772349904352818684682371437

The value of phi(R) is 32009090511053642011646938080535900290740889221587234910
510615506035498237374582276018814019015692579780041430129235933316031791644979
638791139758350009860700246995193430499911398483897120897639955259087470409875
366598591373830615805779319239570083602972481544925330509176977531530358318061
44466131249975602991969588856988898729867579653294934514074112

Factors of R are 5657657687687868767675566745453434983759382793287598327598375
938275928723756788798798090899878778676756564545453342342334324354657657687687
9879879879878687675765644535434287237 
and 
565765768768786876767556674545343498375938279328759832759837593827592872375678
879879809089987877867675656454545334234233432435465765768768798798798798786876
75765644535434276993
#+end_example

**** TODO Study for Quiz 2
	 DEADLINE: <2018-10-25 Thu> SCHEDULED: <2018-10-23 Tue>
	 *STUDY THESE TOPICS*
****** TODO Place notes under topic outlines below for quick access on quiz
	   SCHEDULED: <2018-10-24 Wed>
	 - Encryption
#+BEGIN_EXAMPLE 
RSA Encryption
(n,e) 	- public key
d 		- private key
phi(n)	= (p-1)(q-1) 	- Euler's Totient
n		= p*q		 	- RSA mod
E		= M^e mod n		- Ciphertext (encryption)
#+END_EXAMPLE
	 - Decryption
	 - Signing keys
	 - Review common attacks
****** TODO Create sage page with RSA functionality already installed
****** TODO Include functions for different attacks
**** TODO Homework 7
	 DEADLINE: <2018-11-01 Thu> SCHEDULED: <2018-10-29 Mon>
** CS253
*** Lecture
**** Structs
***** Notes
****** introduction

 A struct is a /class/ without any /methods/ (it only has /attributes/)

 There is more to structs than the above statement, we'll investigate this more.
****** Java comparison

 *KEY SIMILIARITIES*
  - A ~struct~ is a user-definied datatype (primitive c type
  - others...

 *KEY DIFFERENCES*
  - Syntax syntax syntax!
  - A ~struct~ has no methods
  - A ~struct~ has no constructors
  - A ~struct~ cannot inherit members from another ~struct~
  - Memory Management is different

****** Accessing Member Variables in a Struct

| Using a struct variable | Using a pointer vairable |
|-------------------------+--------------------------|
| purple.r = 255;         | pColor->r = 255;         |
| purple.g = 0;           | pColor->g = 0;           |
| purple.b = 255;         | pColor->b = 255;         |

****** Defining struct variables

#+BEGIN_SRC C
struct Color {
	unsigned char r;	//Red 0...255
	unsigned char g;	//Green 0...255
	unsigned char b;	//Blue 0...255
} purple, pink;			//Variables!!!
#+END_SRC
The above example defines a new data type, Color, and also defines two /uniinitialized/ 
color variables, purple and pink
****** Initializing a struct Variable

#+BEGIN_SRC C
struct Color {
	unsigned char r;	//Red 0...255
	unsigned char g;	//Green 0...255
	unsigned char b;	//Blue 0...255
} purple, pink;			//Variables!!!
struct Color purple = {255,0,255};
#+END_SRC
****** Struct Variable operators
	   - Assignment with "=" operator: purple = pink;
	   - Retrieve its address with "&": pColor = &purple;
	   - Accessing members with "." operator: int r = purple.r;
	   - Comparisons (e.g. "==") are *NOT* supported
****** Structs and Functions
	   - Struct variables (and everything in C) are /pass by value/
	    - ~struct Color chosenColor = selectColor(purple);
	   - Passses a _copy_ of the value of the struct purple to the selectColor func
****** Arrays of Structs
	   
struct Color primaries[8]; //An array of 8 Colors
primaries[0] = purple
***** Examples

 #+BEGIN_SRC C
 struct Place {
  int x;             //X-coodr of this Place
  int y;             //Y-coodr of this Place
  struct Place* next;//Address of next palce
 };
 .
 .
 .

 //Define a function to construct/initialize a new Place
 struct Place* newPlace(int xp, int yp){
     struct Place *p = malloc(sizeof(struct Place));
     //malloc - memory allocation
     p->x = xp;
     p->y = yp
     return p;
 }
 #+END_SRC

**** Malloc and Free
***** Notes

 malloc returns (void *)
 /this/ returns a reference to itself

 C lacks java's garbage collection service. you must explicitly /free/ everything
 you alllocate with /malloc/

 If you don't, you *will* /leak/ memory

***** Examples

 #+BEGIN_SRC C
 //Define a struct Place datatype
 struct Place{...};
 .
 .
 //Build an instance of a Place in memory
 struct Place* p = malloc(sizeof(struct Place));
 .
 .
 //Recycle the memory in the Place referenced by p
 free(p);
 #+END_SRC

**** Typedef
***** Notes
	  Basically just an alias to a datatype
***** Examples
	  ~typedef unsigned char unsbyte;~
	  ~typedef struct Color* pColor;~
	  the above definss unsbyte to be an alias for unsigned char
	  typedef does NOT define a new data type
	  this helps to write more readable code
**** Function Pointers
***** Notes
	  *I accidently deleted stuff...missing notes and files*
#+NAME: Function Pointers
#+HEADER: :dir ./src/c
#+HEADER: :file functionPointers.txt
#+HEADER: :tangle ./src/c/functionPointers.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h>)
printf("Hello World");
#+END_SRC

#+RESULTS: Function Pointers
: DEBUG: Entering a string/function foo!

**** Debugging, valgrind
***** Defining Macros 
	  - A macro is 'preprocessed'. C can expand functionality using these macros
***** Debug macro
#+NAME: Function Pointers
#+HEADER: :main no :dir ./src/c
#+HEADER: :tangle ./src/c/debug.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h>)
//in makefile
//use debug target
/*
	CFLAGS = -Wall -std=c99
	EXE=foo

	all: $(EXE)

	debug: CFLAGS += -DDEBUG -g -Og
	debug: $(EXE)
	
	$(EXE): foo.o
		gcc $^ -o $@
*/

//uncomment if in debug.h
//#ifdef DEBUG
#define DPRINT(s) printf("DEBUG: %s\n", s)
//#else
//#define DPRINT(s)
//#endif

int main(){
	//Example usage
	DPRINT("Entering a string/function foo!");
	//This is expanded into printf("DEBUG: %s\n", "Enetering a string/function foo!")
}
#+END_SRC

***** Valgrind
	  - Toolkit popular for memory issues (leaks, bad pointers)
	  - Valgrind is a virtual machine executing your program
	  - See /CS253 class resources/ for examples
**** I/O
***** Terminology
****** Processes
	   - Process id
	   - user id
	   - address space
		 - text: A segment of memory containing executable code
		 - heap: A segment of memory for data
	   - File Descriptors
****** Thread States
	   - RUNNABLE: awaiting a processor to execute it
	   - EXECUTING: A processor is executing your thread
	   - BLOCKED: Awaiting I/O
****** File Descriptors
	   - Each process has a File Descriptor Table
	   - Each active file descriptor is bound to a file
****** Buffers
	   - Each high-level FILE stream has a buffer in user-space
	   - low-level files are buffered in kernel-space
**** Threads, Processes and Data
***** Stack
	  - Return addresses, parameters, and automatic variables
***** Heap
	  - Allocated memory blocks
***** True vs. Pseudo-Concurrency
	  - Processor is a CPU core, an independent processin gunit
	  - /threads/ truly executing concurrenlty is limited by the number of /processors/
	  - /True concurrency/ Modern computer hardware supports several cores and can execute several threads concurrently
	  - /Pseudo-Concurrency/ An operating system time-shares 1...M processors amongs 1...N threads
***** Processes in Unix-Like Systems
	  - dispaly information about each process with
		- ~ps ax~
	  - count the number of executing processes
		- ~ps ax | wc -l~
	  - PID - process ID
	  - PPID - parent process id
	  - UID - user id
	  - GID - group id
	  - VSZ - vitrual storage size (includes 'swapped' memory)
	  - RSZ - resident storage size ("not swapped memory")
	  - WCHAN - wait channel (the reason a process is waiting)
	  - STAT - process status flags
	  - COMMAND - executing program and arguments if available

****** fflush(stdout); - flushes a stream
**** Fork and Wait
	 - fork creates a new process
	   - Kernel copies parent's (process) memory into the child
	   - parent resumes executing following fork
	   - the child begins executing within fork
	   - both code execute the same code
	   - variable changes by one process are not seen by the other
	 - wait awaits the exit of any child process
**** Execute Processes
#+NAME: execve
#+HEADER: :include '(<unistd.h>, <stdio.h>,<stdlib.h>)
#+BEGIN_SRC C
char* fileName="ls";
char *newargv[] = {fileName,"hello", "world",NULL};
//convention is to have last element be NULL, and first be argv[0]
char *newenviron[]={NULL};
execve(newargv[0], newargv[1], newenviron);
//execve does not return, unless an error occurs (returns -1)
//result = execve(fileName, argv[], envp[]);
//char *fileName: name of an executable program
//char *argv[]: array of arguments for the new program
//char *envp[]: Array of environment variables for new program
#+END_SRC
**** Enviornment variables
	 - set: display all environ vars
	 - export FOO=value: export environ var FOO having value to all subsequent cmd
	 - unset FOO: Remove definition of environ var
	 - echo $FOO: Display value of enviornment variable FOO
*** In-Class Exercises
#+NAME: Fork and Wait
#+HEADER: :dir ./src/c/ :file forkAndWait.txt
#+HEADER: :tangle ./src/c/forkAndWait.c
#+HEADER: :exports results
#+HEADER: :main no
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <unistd.h> <sys/types.h> <sys/wait.h>)
void newFork(){
	//Create a duplicate process
	int pid = fork(); //Fork will return twice
	//Fork 'creats' a thread to run child and parent concurrently
	//This code block after the fork() call is executed twice!
	if (pid==0){
		for(int i=0; i<1000; ++i){
			printf("I am Luke Skywalker!\n");
		}
		exit(0);//ends current process
	} else if(pid>0){
		int exitStatus;
		for(int i=0; i<1000; ++i){
			printf("I am Darth Vader\n");
		}	
		wait(&exitStatus);//saves child exitStatus into named var. Waits til 
		//child exits before continues
		exit(0);
	}
	perror("There is a disturbance in the force.");
	exit(-1);
}

int main(){
	newFork();
	return 0;
}
#+END_SRC

#+RESULTS: Fork and Wait
[[file:src/c/forkAndWait.txt]]

*** Assignments
**** DONE P4 - Smash Simplified Shell Assignment
     DEADLINE: <2018-10-14 Sun>

**** INPROGRESS P5 - Smash Simplified Shell
	 DEADLINE: <2018-11-04 Sun>
** CS230
*** Assignments
**** TODO Sign up for exam2
	 SCHEDULED: <2018-10-16 Tue>
**** TODO Take IP-Quiz
**** TODO update journal
	 SCHEDULED: <2018-10-16 Tue>
**** TODO Update Journal entry
	 DEADLINE: <2018-10-10 Tue>
	 - [ ] include link to license webpage as a plus
	 - [ ] look up something related to privacy/cookies/confidentiality
	 - [ ] include personal notes into the file
*** Lecture
**** Intellectual Property
***** Closed Source
****** Software Licenses
******* Proprietary LIcense (E.g. Microsoft
		- Manufactuer reserves all rights /not expressly granted/
***** Open Source
****** Notes
	 - Is open source software free?
	 - This isn't necessarily the case
	 - what do you pay for in buying /free/ software?
		 - Technical support
		 - Testing
		 - proprietary aps enhancing the distro
****** Software Licenses
******* Permissive License(s) (E.g. MIT)
  A /permissive license/ imposes minimal restrictions on the 
  distribution of the software

  - Berkeley Systems Division (BSD) License
  - Apache LIcense
  - MIT License
  
  Permits the software to be incorporated into proprietary products
******* Protective ("copy-left license)
  - A /copyleft license/ offers the author of a /derivative work/
	- The right to use the licensed software
	  - So long as the /derivative work/ is also distributed with the /copyleft license/
  - Copyleft software cannot be incorporated into a proprietary product (or even a permissive open source product)
  - Copyleft software can be incorporated into another copyleft product
  - GNU general Public License is an example of this

***** Public Domain
***** Software Patents
****** Patent laws
	   - vary country to country
	   - We will focus on US software patents
	   - Obtaining a US patent does *NOT* guerentee protection globally
	   - Treaties (eg World Trade Organization's Agreement) have tried to change this
		 
****** What does a Patent do?
	   - provides certain rights to a patent holder
	   - In exchange for the complete disclosure of the invention
	   - No one may build, use, sell or import/export without patent holder permis.
	   - Term limited (20 years has been typical)
****** Patent Requirements
	   - Processes, machines, articles of manufacture and compositions of matter
		 - Exceptions (CANNOT be patented)
		   - Abstract ideas
		   - laws of nature
		   - natural phenomenon
	   - Novel - unique, can't be easily determined
	   - Useful
	   - Non-Obvious
****** Copyright vs. Patent
	   - A computer program is an expression of a method, an implementation, and can be copyrighted
	   - A patent protects a program's underlying methodolgy, not the implmenatation.
	   - But...
		 - US supreme court ruled that a numerical algorithm (abstract idea) cannot be patented
	   - Patents protect methodolgy, not an algorithm
	   - The supreme cour ruling itself still has some exceptions
	   - [[https://www.bitlaw.com][bitlaw - software law resource]]
****** Software Patent Take-Aways
	   - Patents are expensive and time-consuming
	   - Patents may not be the best way to protect your software
	   - Preferred methods include:
		 - Trade Secrets
		 - Copyrights
		 - Public Domain (may block others from patenting it!!!)
	   - Patents look cool on your resume
***** Trademarks
****** What is a trademark?
	  - Sign, symbol or logo
	  - Word, Phrase or name
	  - Design or an image
	  - (r)
****** About Tradmarks
	   - Another form of intellectual property
	   - are 'recognizable" like a signature
	   - protects brand names, logos, etc
	   - [[https://www.uspto.gov/trademark][Register a trademark]]
****** Symbols for trademarks
	   - (r) is for registered tradmarks
	   - ^TM is for unregistered trademarks
****** Trademarks for Developers
	   - Even open-source projects may have trademarks!
	   - We encounter trademarks when we implement user interfaces displaying our company's trademark
	   - Most company's have policies rgulating the use and protection of tehir trademark
**** Privacy
***** Notes
	 - Aspects of privacy (as per CS23)
	   - Confidentiality
	   - Integrity
	   - Right to be let alone
	 - privacy expectations vary amongst cultures

***** Definitions
	  - Authentication
		- Protection of confidential information requires us to:
		  - Identify who wnats to access the data
		  - Identify who owns the data
		- /Authentication/ associates an /identity/ with a subject activity
		- Factors
		  - Enables a system to identify users
		  - Multi-factor authentication
	  - Authorization
		- determines what rights a subject has to a datum
		  - ex: triplejay2013 is authorize to read but not write file, foo.txt
	  - Confidentiality Policy
		+ defines who is allowed specific rights to what data
		+ Confidentiality: What can be access
		  1. The credit card number you used on-line
		  2. your phone number
		  3. your eMail address
		  4. residential address
		  5. shopping history (what and where)
		  6. current location
		  7. health history
		  8. browser history
		  9. texting history
		  10. DNA
		  11. Password
	    + Confidentiality: Who can access
		  1. Family
		  2. real-world friends
		  3. people on social media
		  4. retailers
		  5. employwer
		  6. political party
		  7. police
		  8. federal government
		+ Confidentiality: Data in Transit
		  - Symmetric-key cryptography
			- Believed to provide strong security
			- Both sender and reciever must know secret key
			- /Key distribution problem/: how to share the secret key
		  - Asymmetric-key cryptography (public-key)
		+ Confidentiality: Data at rest
		  - Hash values are an example of a one-way function (easy one way, hard the other)
		  - Hash values are stored, not the actual passwords
		  - Cookies Example
			- Cookies store state information in clients (browsers
*** TODO Exam Review
	SCHEDULED: <2018-10-24 Wed>
	- Derivative Work (GPL License is example, gzip)
	  - Something that uses software in its implementation
	- Permissive License (MIT, BSD, Apache)
	- Copy-left license (GPLv2)
	  - derivative works are required to license their software under the same license
	- Trade Secret Definition
	  - Vulnerabilities of Trade Secret
		- Guessable?
	- Copyrights
	  - Automatic - no action is required
	  - However some action can be taken to ensure the copyright
	  - What are your rights with CopyRight?
	- NO ETHICAL CODE REVIEW

** CS310
*** Lecture
**** Review
**** Predicates
***** WHERE
		Returns three options
		1. TRUE
		2. FALSE
		3. UNKNOWN
***** Logical Operators
	  + AND
		ex: 
#+BEGIN_SRC sql
SELECT * FROM Student
WHERE FIRSTNAME = 'Hope' OR LastName = 'Geller';
#+END_SRC
	  + OR
	  + NOT
***** Compariosn Operators
	  Used to check for comparative sameness between two expressions
	  (=,!=, <, >,<=,>=, LIKE)
***** LIKE
	   - The 'wildcard' in SQL is '%'
	   - Different than 'equality'. Checks for partial equality
	   - ex:
#+BEGIN_SRC sql
SELECT * FROM Student WHERE LastName LIKE 'S%';
#+END_SRC
***** ORDER BY
	  - orders information by (date, name, id, etc...)
#+BEGIN_SRC sql
SELECT *
FROM Class
ORDER BY Name ASC;	 
-- ORDER BY MaximumStudents, Name
-- ASC means ascending
-- DESC means descending
#+END_SRC
**** ALTER TABLE & FOREIGN KEY
***** Syntax
#+BEGIN_SRC sql
ALTER TABLE <tablename> ADD FOREIGN KEY (<columnname>)
REFERENCES <anothertable> (<columnname>)
#+END_SRC
**** Scalar Function
A function that takes zero or more parameters. It evaluates inputs and reutrns a result
 - Will return one value per record that it evaluates
 - Never changes stored data itself
 - Can be found in SELECT,INSERT, UPDATE,and DELETE queries

examples: CONCAT DATE_ADD LENGTH SUBSTRING NOW()

AS: creates an alias
SELECT CONCAT(FirstName, ' ', LastName) AS FullName, BirthDate
FROM Student
**** Procedure
***** Notes
	 - A database structure or construct that contains one or more sql queries
	 - Unlike functions, procedures can change data
***** Benefits
	  - Avoid duplicating database code
	  - Easier to tweak performance or behaviour in the database
	  - Can provide more security by limiting user access
	  - Encourages encapsulation
***** Examples
		
#+BEGIN_SRC sql
Delimiter $$
Create Procedure GetShortNameStudents()
BEGIN
	SELECT FirstName, LastName
	FROM Student
	WHERE LENGTH(FirstName) <= 5;
END;
$$

/*
	Use with:
CALL GetShortNameStudents();
*/

-- Another example
Delimiter $$
-- here I defined an input variable maxLength of type INT
Create Procedure GetSHortNameStudents2(IN maxLength INT)
BEGIN
	SELECT FirstName, LastName
	FROM Student
	WHERE LENGTH(FirstName) <= 5;
END;
$$
/*
	Use with:
CALL GetShortNameStudents2(6);
*/
#+END_SRC
**** Joining Tables
***** JOIN clause
	  - allows you to connect different sets of data
	  - you can have more than one JOIN clause and connect multiple sets together
	  - you can use LEFT or RIGHT joins, (INNER is an optional keyword and is
		default if no other keywords are present)
	  - Joining tables is often accomplished using a foreign key column that connects 
		to a primary key column in another table
	  - To connect Key columns you will use the ON clause after the JOIN clause
**** Updating a database

*** Assignments
**** Final Project
	 I can start the final project now
**** Homwk 3
	 
#+BEGIN_SRC python
def hello():
	print("Hello World")

hello()
#+END_SRC

#+BEGIN_SRC python
def hello():
	return "Hello World"
print(hello())
#+END_SRC

#+RESULTS:
**** TODO Homework 6-Pair
	 DEADLINE: <2018-10-17 Wed>
**** TODO Study for quiz
	 DEADLINE: <2018-10-16 Tue>
