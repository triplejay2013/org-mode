#+TITLE: BSU
#+AUTHOR: Justin Johnson

* Accelerated Masters Application
  DEADLINE: <2018-12-08 Sat>

** TODO Print off application
** TODO Look at graduate Catalog
** TODO Contact and meet with falculty

- [ ] Ask them what projects I might participate in that field of study
- [ ] what courses I should take if I pursue their emphasis

** TODO Spring Semester Planning
* Fall 2018
** Math307
*** Lecture
**** RSA
***** Note
****** Key Generation
Key Generation
 1. Choose two primes p,q and compute:
    n=p*q
    phi(n)=(p-1)*(q-1)
 2. Choose a 'random' number t such taht gcd(x,phi(n))=1
 3. Compute e=t^-1 mod phi(n)
	
Public Key:		(n,e)
Private Key:	(t, phi(n))

*RSA ENCRYPTION*
E=M^e mod n
E=ciphertext of M

*RSA DECRYPTION*
M=E^t mod n

*MISC*
e=t^{-1} mod phi(n)
t=e^{-1} mod phi(n)
e is public
phi(n) is private

*FACTORING PROBLEM*
Given n that is a product of two primes, find its primes
****** Attacks
******* COMMON MODULUS ATTACK
Suppose that same message M < n is sent to two different parties whose
encryption exponents respectiveily are e_1 and e_2 and suppose that gcd(e1,e2)=1

 - Assume gcd(e1,e2) = 1
 - gcd(a,b) = a*x + b*y
   for some x,y belonging to Z
 - Using the extendid Euclidean algorithm one can find x and y such that:
   1 = gcd(e1,e2)=e_1 * x + e_2 * y
 - The original message can be found by:
   E^x * F^y mod n 
   = ((M^{e_1} mod n)^x * (M^{e_2} mod n)^y) mod n
   = (M^{e_1})^x * (M^{e_2})^y mod n
   = M^{e_1 * x + e_2 * y} mod n 
   = M^1 mod n 
   = M

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

The encrypted messages are: 
E=M^{e_1} mod n  	(Alice)
 and 
F=M^{e_2} mod n		(Bob)

******* COMMON ENCRYPTION EXPONENT
/assume same people and messages as above/
Assume that gcd(n_1,n_2)=1
Plaintext:	M < n1,n2
E_1=M^e mod n_1	(Alice)
E_2=M^e mod n_2	(Bob)

Using CRT we can solve 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 for M.
 
 M is the unique solution of 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 modulo n1*n2
 	M mod n1*n2 = M because M <n1,n2

	*CHINESE REMAINDER THEOREM (CRT)*
	let n1, n2, ... , nk be natural numbers such that for i,j distinct incices one
	has gcd(ni,nj)=1

	then the system of linear congruences has a solution which is unique modulo:
		N=n1*n2*..*nk
		
    Solution: x=b1*N1*x1 + b2*N2*x2+...+bk*Nk*xk mod N
    where Ni=N/ni and xi=(1/Ni) mod ni
******* COMMON MODULUS ATTACK (Directory Attack?)

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

n1 != n2

If gcd(n1,n2) = d > 1
	this means that n1 and n2 share more than 1 factor (other than 1|N)
	then d is one of the primes of n1 *and* n2

***** Examples
****** Attacks:COMMON MODULUS ATTACK (Directory ATTACK?)
From Sage:
#+BEGIN_SRC python

# an example of rsa common modulos attack
# (1) Choose three large primes
p=next_prime(16718273096520398462809571209865120938651029871098236409287109865983649721650123640975210352)
q1=next_prime(1092836510928346091832650987120398470239861059836018923750892136509812349086230985709128349)
q2=next_prime(1230519283509213864092710983561209836590218364921836509827340892370561029309871423498021350)
# (2) Compute n1=p*q1
#             n2=p*q2
n1=p*q1
n2=p*q2
# (3) Computer phi1=(p-1)*(q1-1)
#              phi2=(p-1)*(q2-1)
phi1=(p-1)*(q1-1)
phi2=(p-1)*(q2-1)
# (4) Choose two random numbers t1, t2 such that:
#                 gcd(t1,phi1)?=1
#                 gcd(t2,phi2)?=1
t1,t2=31,next_prime(1024)
while(gcd(t1,phi1)!=1):
    ++t1
while(gcd(t2,phi1)!=1):
    ++t2
# (5) Compute:
#      t1^-1 mod phi1
#      t2^-1 mod phi2
d1=inverse_mod(t1, phi1)
d2=inverse_mod(t2,phi2)

#Directory Attack:
x=xgcd(n1,n2)
print(x[0]) #Calculated prime gcd(n1,n2)=p
print(p)    #Original prime

#+END_SRC
*** Assignments
**** TODO Homework 4 [0/1]
     DEADLINE: <2018-10-03 Wed 11:16>

	 - [ ] part 1
       - Describe how I found my solutions. Place answers in document
	 - [ ] part 2
       - Place code for solving the two parts here

** CS230
*** Intellectual Property
**** Closed Source
***** Software Licenses
****** Proprietary LIcense (E.g. Microsoft
	   - Manufactuer reserves all rights /not expressly granted/
**** Open Source
***** Notes
	- Is open source software free?
	- This isn't necessarily the case
	- what do you pay for in buying /free/ software?
		- Technical support
		- Testing
		- proprietary aps enhancing the distro
***** Software Licenses
****** Permissive License(s) (E.g. MIT)
 A /permissive license/ imposes minimal restrictions on the 
 distribution of the software

 - Berkeley Systems Division (BSD) License
 - Apache LIcense
 - MIT License
  
 Permits the software to be incorporated into proprietary products
****** Protective ("copy-left license)
 - A /copyleft license/ offers the author of a /derivative work/
   - The right to use the licensed software
	 - So long as the /derivative work/ is also distributed with the /copyleft license/
 - Copyleft software cannot be incorporated into a proprietary product (or even a permissive open source product)
 - Copyleft software can be incorporated into another copyleft product
 - GNU general Public License is an example of this

**** Public Domain
*** Assignments
**** TODO Update Journal entry
	 DEADLINE: <2018-10-02 Tue>
	 - [ ] include link to license webpage as a plus
	 - [ ] look up something related to licensing
	 - [ ] include personal notes into the file
** CS253
*** Assignments
**** INPROGRESS P4 - Smash Simplified Shell Assignment
     DEADLINE: <2018-10-14 Sun>

*** Lecture
**** Structs
***** Notes

 A struct is a /class/ without any /methods/ (it only has /attributes/)

 There is more to structs than the above statement, we'll investigate this more.

 *KEY SIMILIARITIES*
  - A ~struct~ is a user-definied datatype (primitive c type
  - others...

 *KEY DIFFERENCES*
  - Syntax syntax syntax!
  - A ~struct~ has no methods
  - A ~struct~ has no constructors
  - A ~struct~ cannot inherit members from another ~struct~
  - Memory Management is different

	**UNFINISHED**
 | C                | Java |
 | //A Place struct |      |
 | struct Place {   |      |
 | int x;           |      |
 | int y;           |      |
 | }                |      |

 malloc returns (void *)
 /this/ returns a reference to itself

***** Examples

 #+BEGIN_SRC C
 struct Place {
  int x;             //X-coodr of this Place
  int y;             //Y-coodr of this Place
  struct Place* next;//Address of next palce
 };
 .
 .
 .

 //Define a function to construct/initialize a new Place
 struct Place* newPlace(int xp, int yp){
     struct Place *p = malloc(sizeof(struct Place));
     //malloc - memory allocation
     p->x = xp;
     p->y = yp
     return p;
 }
 #+END_SRC

**** Malloc and Free
***** Notes

 C lacks java's garbage collection service. you must explicitly /free/ everything
 you alllocate with /malloc/

 If you don't, you *will* /leak/ memory

***** Examples

 #+BEGIN_SRC C
 //Define a struct Place datatype
 struct Place{...};
 .
 .
 //Build an instance of a Place in memory
 struct Place* p = malloc(sizeof(struct Place));
 .
 .
 //Recycle the memory in the Place referenced by p
 free(p);
 #+END_SRC

** ECE330
*** Assignments
**** DONE Lesson 13 - Ch. 12 Problems (all)
     DEADLINE: <2018-10-02 Tue>
**** TODO Quiz - Ch. 12 OpenNote OpenBook
	 DEADLINE: <2018-10-02 Tue 18:00>
**** TODO Lesson 15 - Ch. 14 Problems (all)
     DEADLINE: <2018-10-09 Tue>

*** Lecture
**** Bit Manipulation
***** Notes
****** Abstractions
 *These abstractions can be implemented with simple Bitwise operations*
 1. Test Bit
	find what bit (?) is in a location
 2. Set Bit
	makes a bit a '1'
 3. Clear Bit
	makes a bit a '0'
 4. Toggle Bit
	1->0, 0->1
 5. Get Bit(s)
 6. Put Bit(s)

****** Register Represenation and truth tables
******* Mask Register
	 					        															 - BOI (bit of interest, SIZE =1
																							 V
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
 |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  B |    |    |    |   |   |   |   |   |   |   |   |   |   |
 |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
																										 *OFFSET (from bits 0-12)*

******* Truth Tables
  - And (Effectively 'Test Bit' & 'Clear Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |---|_ Clear Bit
	| 0 | 1 | 0 |---|
	| 1 | 0 | 0 |---|_ Test Bit
	| 1 | 1 | 1 |---|

  - OR (Effectively 'Set Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |
	| 0 | 1 | 1 |
	| 1 | 0 | 1 |---|_ Set Bit
	| 1 | 1 | 1 |---|

  - EOR (Effectively 'Toggle Bit')
	| M | B | F |
	|---+---+---|
	| 0 | 0 | 0 |
	| 0 | 1 | 1 |
	| 1 | 0 | 1 |---|_ Toggle Bit
	| 1 | 1 | 0 |---|
   
******* Expr and Instr
 |                             | and | or   | eor | not | shift-left | shift-right |              |
 |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
 | assembly time mask          | &   | pipe | ^   | ~   | <<         | >>          | expressioins |
 |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
 | Target operation (run time) | and | orr  | eor | mvn | lsl        | lsr         | instructions |
****** Mask/Inverse Mask
		- A mask is a filter that allows us to focus on BOI (Bit of Interest)
		- Values from some register we want to retrieve bits from, are copied into a mask register
		- Represent bits (example from book)
			- ldr r4, =0b00000000000000100000000000000000000 (not counted) //too lengthy
			- ldr r4, =0x00400000 //a little intuitive
			- ldr r4, =4194304 //unclear, don't use
			- ldr r4, =(1<<22) //intuitive which bit we are considering
		- *Mask* - all bits but the BOI are '0'
		- *Inverse mask* = all bits but the BOI are '1'
****** Put and Get Bit
		+ Get Bit(s) - AND mask can get the BOIs
		+ Put Bit(s) - takes as input, a bit value (0 or 1). Takes value at runtime and puts into position
******* Normalize
******* De-Normalize
***** Examples
****** Bit Manipulation Abstractions
#+BEGIN_EXAMPLE
# testbit(boi=14)
ldr r4,=0x12345678		//0x12345678 - target
ldr r2,=(1<<14)			//r2: 0x00004000 - mask
and r2,r4,r2			//r2: 0x12345678 - apply mask

#setbit(boi=15)
ldr r4, =0x12345678		//r4: 0x12345678
ldr r2,=(1<<15)			//r2: 0x00008000 - create mask
orr r2,r4,r2			//r2: 0x12345678 - apply mask
.
.
.
Check Blackboard for more examples pdf file in this directory
#+END_EXAMPLE
[[file:resources/BitManipulationAbstractions.pdf][More Examples Here]]
*** Lab
**** TODO Pre-Lab 6: Device Memory
     DEADLINE: <2018-10-03 Wed 14:00>

** CS310
*** Lecture
**** Review
**** Predicates
***** WHERE
		Returns three options
		1. TRUE
		2. FALSE
		3. UNKNOWN
***** Logical Operators
	  + AND
		ex: 
#+BEGIN_SRC sql
SELECT * FROM Student
WHERE FIRSTNAME = 'Hope' OR LastName = 'Geller';
#+END_SRC
	  + OR
	  + NOT
***** Compariosn Operators
	  Used to check for comparative sameness between two expressions
	  (=,!=, <, >,<=,>=, LIKE)
***** LIKE
	   - The 'wildcard' in SQL is '%'
	   - Different than 'equality'. Checks for partial equality
	   - ex:
#+BEGIN_SRC sql
SELECT * FROM Student WHERE LastName LIKE 'S%';
#+END_SRC
***** ORDER BY
	  - orders information by (date, name, id, etc...)
#+BEGIN_SRC sql
SELECT *
FROM Class
ORDER BY Name ASC;	 
-- ORDER BY MaximumStudents, Name
-- ASC means ascending
-- DESC means descending
#+END_SRC
*** Assignments
Assignments will build off of eachother,
use only one database for all assignments
**** Final Project
	 I can start the final project now
**** Homwk 3
	 
