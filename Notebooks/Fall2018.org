#+TITLE: BSU
#+AUTHOR: Justin Johnson

*BOLD*
_UNDERLINE_
=VERBATIM=
~CODE~
/ITALIC/

* Spring2019 Registration Prep
** INPROGRESS Consult Advisor to finalize Spring schedule
   SCHEDULED: <2018-10-22 Mon 10:00>
   :PROPERTIES:
   :ARCHIVE_TIME: 2018-11-12 Mon 12:09
   :ARCHIVE_FILE: ~/.emacs.d/Notebooks/BSU.org
   :ARCHIVE_OLPATH: Spring2019 Registration Prep/Spring 2019 Plan
   :ARCHIVE_CATEGORY: BSU
   :ARCHIVE_TODO: INPROGRESS
   :END:
   | Course    | Description                         | Credits | Instructors            |
   |-----------+-------------------------------------+---------+------------------------|
   | UF 200    | Foundations of Ethics and Diversity |       3 |                        |
   | CS 361    | Intro to Theory of Comp             |       3 |                        |
   | CS 441    | Computer Architecture               |       3 |                        |
   | CS 453    | Operating Systems                   |       3 | Shane Panter/Amit jain |
   | CS-HU 271 | Agile Developement                  |       1 |                        |
   | ***         | Work U                              |      3  |                        |
   | ^         | Total:                              |      13 |                        |
   #+TBLFM: $3=vsum(@2..@-1)
*** Required Courses
	| UF 200 | CS 361 | CS 441  | CS 453    | CS 471 |
	|--------+--------+---------+-----------+--------|
	| CS 481 | CS 488 | CS 421? | CS-HU 271 |        |
*** Spring 2019 Plan
*** Fall 2019 Plan
	| Course | Description          | Credit |
	|--------+----------------------+--------|
	| CS 471 | Software Engineering |      3 |
	| CS 421 | Algorithms           |      3 | **Covered by transfer?
	|        |                      |        | **Accel. Masters Courses?

* Misc Items
* Need to know commands for emacs
** Quick Commands
	- C-x C-q to disable read-only buffer
	- C-c C-e to export selected (whole file default) to certain format
	- C-c s - auto insert source block
	- C-x C-c to exit file
	- *S-right or S-left - cycle list type or TODO header types*
	[[https://justin.abrah.ms/emacs/literate_programming.html][Literate Programming]]
	- C-c C-v C-t  Tangle a code src block 
** Agendas
   -C-c a (t)
   	- opens up agenda view, compiles todo list with t option
	  - press t again to cycle TODOs
	  - "N r" means "1 r" to recompile list with specific keywords
	- (n)ext (p)revious
	- RET go to location of item and delete other windows
	- TAB go to location but keep current windows open
	- (f)orward or (b)ackward in time
	- '.' today
	- (j)ump prompt for date and go there
	- and more! Start practicing!

[[http://sachachua.com/blog/2007/12/emacs-getting-things-done-with-org-basic/][Agenda tips]]
** Tables
   - C-c | - creats table
   - S-M-<right> - inserts column to the right
* Fall 2018
** ECE330
*** Lecture
**** Notes
***** Assembly
****** Directives
	   - .org ###
		 - Use up ### bytes of memory. 'Skips' ### for the location counter
****** Bit Manipulation
******* Notes
******** Abstractions
   *These abstractions can be implemented with simple Bitwise operations*
   1. Test Bit
	  find what bit (?) is in a location
   2. Set Bit
	  makes a bit a '1'
   3. Clear Bit
	  makes a bit a '0'
   4. Toggle Bit
	  1->0, 0->1
   5. Get Bit(s)
   6. Put Bit(s)

******** Register Represenation and truth tables
********* Mask Register
	 					        															   - BOI (bit of interest, SIZE =1
																							   V
   |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
   | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
   |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  B |    |    |    |   |   |   |   |   |   |   |   |   |   |
   |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---|
																										   *OFFSET (from bits 0-12)*

********* Truth Tables
	- And (Effectively 'Test Bit' & 'Clear Bit')
	  | M | B | F |
	  |---+---+---|
	  | 0 | 0 | 0 |---|_ Clear Bit
	  | 0 | 1 | 0 |---|
	  | 1 | 0 | 0 |---|_ Test Bit
	  | 1 | 1 | 1 |---|

	- OR (Effectively 'Set Bit')
	  | M | B | F |
	  |---+---+---|
	  | 0 | 0 | 0 |
	  | 0 | 1 | 1 |
	  | 1 | 0 | 1 |---|_ Set Bit
	  | 1 | 1 | 1 |---|

	- EOR (Effectively 'Toggle Bit')
	  | M | B | F |
	  |---+---+---|
	  | 0 | 0 | 0 |
	  | 0 | 1 | 1 |
	  | 1 | 0 | 1 |---|_ Toggle Bit
	  | 1 | 1 | 0 |---|
   
********* Expr and Instr
   |                             | and | or   | eor | not | shift-left | shift-right |              |
   |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
   | assembly time mask          | &   | pipe | ^   | ~   | <<         | >>          | expressioins |
   |-----------------------------+-----+------+-----+-----+------------+-------------+--------------|
   | Target operation (run time) | and | orr  | eor | mvn | lsl        | lsr         | instructions |
******** Mask/Inverse Mask
		  - A mask is a filter that allows us to focus on BOI (Bit of Interest)
		  - Values from some register we want to retrieve bits from, are copied into a mask register
		  - Represent bits (example from book)
			  - ldr r4, =0b00000000000000100000000000000000000 (not counted) //too lengthy
			  - ldr r4, =0x00400000 //a little intuitive
			  - ldr r4, =4194304 //unclear, don't use
			  - ldr r4, =(1<<22) //intuitive which bit we are considering
		  - *Mask* - all bits but the BOI are '0'
		  - *Inverse mask* = all bits but the BOI are '1'
  #+BEGIN_EXAMPLE 
  1 << 12
  12: acts like the 'offset' for the data
  0b111 << 12: sets bits 12, 13, and 14 to 1

  ~0 << 3: 11111000

  Normalize-Denormalize
  Static mask
  ~(~0 << 3) << 12
		  |      |_
		  V	     V
      sizeInBits  offset
  #+END_EXAMPLE
******** Put and Get Bit
		  + Get Bit(s) - AND mask can get the BOIs
		  + Put Bit(s) - takes as input, a bit value (0 or 1). Takes value at runtime and puts into position
********* Normalize
********* De-Normalize
******** Normalize/Denormalize
		 Normalize - Shift bits /aligned right/
		 Denormalize - Shift bits to desired location
******* Examples
******** Bit Manipulation Abstractions
  #+BEGIN_EXAMPLE
  # testbit(boi=14)
  ldr r4,=0x12345678		//0x12345678 - target
  ldr r2,=(1<<14)			//r2: 0x00004000 - mask
  and r2,r4,r2			//r2: 0x12345678 - apply mask

  #setbit(boi=15)
  ldr r4, =0x12345678		//r4: 0x12345678
  ldr r2,=(1<<15)			//r2: 0x00008000 - create mask
  orr r2,r4,r2			//r2: 0x12345678 - apply mask
  .
  .
  .
  Check Blackboard for more examples pdf file in this directory
  #+END_EXAMPLE
  [[file:resources/BitManipulationAbstractions.pdf][More Examples Here]]
****** Mutator and Accessor
******* Definitions
  | get | Accessor | function that retrieves a value from a private member variable                                                                |   |
  |-----+----------+-------------------------------------------------------------------------------------------------------------------------------+---|
  | set | Mutator  | a member function that stores a value in a private member variable, or changes its value in some way (setLength and setWidth) |   |

  *IMPORTANT* Accessors do not change an object's data, so they
  should be marked ~const~ (getLength and getWidth)

****** Pointers and Arrays in Assembly
******* Pointers

  [[https://emacs.stackexchange.com/questions/9612/does-org-mode-has-a-assembly-highlight][Assembly Babel-support]]
  #+NAME: Pointer Example
  #+BEGIN_SRC asm
  .text
  // DEREFERENCING DATA
  ldr r0,=A //est. addr. to var. A in r0
  ldr r1,[r0,#0] // dereference data here

  // DEREFERENCING POINTERS (3-step process)
  ldr r0,=PA	// Load pointer
  ldr r1,[r0] // Load address the pointer contains
  ldr r2,[r1]	// use value at address referenced by PA
  //===========
  ldr r0,=PB
  ldr r1,[r0]
  ldrb r2,[r1]
  //===========
  ldr r0,=PC
  ldr r1,[r0]
  ldrb r2,[r1]

  .data
  A	.word	0x11111111
  PA:	.word	A	# This is a pointer to A
  B	.byte	0x11111111
  PB:	.word	B	# This is a pointer to B
  C	.short	0x11111111
  PC:	.word	C	# This is a pointer to C
  #+END_SRC
******* Arrays
  #+NAME: Array example
  #+BEGIN_SRC asm
  .data
  ARRAY1: 	.word	1,2,3,4,5,6,7,8
  ARRAY_END: 	.word	1,2,3,4,5,6,7,8

  .equ ARRAY_SIZE,
	  (ARRAY_END - ARRAY1)/4 	// a word is 4 bytes, for each elment in the array. 
							  //The size in bytes divided by 4 bytes gives us the size
  #+END_SRC

  #+NAME: Array examples ASCII
  #+BEGIN_SRC asm
  ARRAY1: 	.byte 	0x62, 0x72, 0x6F, 0x6E, 0x63,0x6F,0x73,0x00
  ARRAY2: 	.byte 	'b','r','o','n','c','o','s','\0' //appending \0 makes a string
  ARRAY3: 	.ascii	"broncos"
  ARRAY4: 	.string	"broncos" 						//makes a string
  ARRAY5: 	.asciz	"broncos"						//makes nul-terminated string
  #+END_SRC
******* ASCII
		- ASCII - American Standard Coding Information Interchange
****** ADC (Analog to Digital Converter, also see DAC)
******* Notes
******** SAR (Successive Approximation Register)
		 - Fast ADC implmentation
		   - Uses binary search ( O(logn))
******** Graunularity/Resolution
		 - Number of bits to represent input/output
******** Equations (Memorize, or know when to use)
		 - Vres = (Vref)/2^n = Vlsb
		   - Vref (aka range: bits 0 to 4)
		   - n = num bits
		   - Voltage of least sig. bit
		 - ADC = floor((Vin * 2^n)/Vref) = floor(Vin/Vres)
		   - Vin is the input voltage (2.4v)
		   - outputs a count (in binary, ex: 2 is 010)
			 - This coun represents volume magnitutde (level)
		 - Vadc = ADC * Vres 
		   - Vin (analog input)
		 - Noise = Vin - Vadc 
****** Interrupts - Enabler for the Modern Computer (Operating System)
******* Exceptions
******** Interrupts
********* Hardware Interrupts
********* Software Interrupts
******** Faults
		 - Computer (program) crashes
***** C
****** C-data types 
| data type | bits | example                                  |
|-----------+------+------------------------------------------|
| char      |    8 | unsigned char, signed char(char) - ASCII |
| short     |   16 | unsigned short, signed short             |
| int       |   32 | unsigned int, signed int                 |

#+NAME: Declaring the Variable
#+BEGIN_SRC C
	unsigned int c;
			int c;//signed
	signed int c;
#+END_SRC
****** C and GDB
	 - when compiling a c program in this class
	   - gcc -g -o prog prog.c
	   - (gdb) break main
		 - this puts a breakpoint for gdb
	   - print /x - print hex
	   - print /z - print hex, zero-padded

****** Basic C expressions and Statements
******* Strings
	   - char msg1[] "hello world";
	   - sizeof(msg1)=12 - includes nul terminator
	   - strln(msg1)=11 - does NOT include nul terminator
******* Structs
#+BEGIN_SRC C
//Each member of the struct takes up space according to the data-type size
struct gpio_port{
	int a;
	short b;
	char c;
};
#+END_SRC
******* Unions
#+BEGIN_SRC C
//Each member has the same size
union xyz {
	int x;
	short y[2];
	char z[4];
}
union xyz a;
union xyz a ={0x12345678};
#+END_SRC
In memory, xyz looks like:
|    Address | bytes               |
|------------+---------------------|
| 0x20000000 | 0x78 0x56 0x34 0x12 |
x - would return the whole 32 bit value
y[0] - would return short starting at index 0 (0x78 0x56)
z[0] - would return a byte starting at index 0 (0x78)
*The size of a union is the size of its largest member*

***** GDB
	  - step/next/finish
	  - backtrace: frames - r7 - "frame Pointer"
	  - break main, main: all_done, #<line#>, function_name
	  - info locals - prints out variabls known in current frame
**** Assignments
***** SUBMITTED Lesson 13 - Ch. 12 Problems (all)
      DEADLINE: <2018-10-02 Tue>
***** SUBMITTED Quiz - Ch. 12 OpenNote OpenBook
	  DEADLINE: <2018-10-02 Tue 18:00>
***** SUBMITTED Lesson 15 - Ch. 14 Problems (all)
	  SCHEDULED: <2018-10-08 Mon> DEADLINE: <2018-10-09 Tue>
***** SUBMITTED Lesson 17 - Ch. 15, 16 Problems (all)
	  DEADLINE: <2018-10-16 Tue> SCHEDULED: <2018-10-15 Mon>
***** CANCELED Prelecture read and review
	  DEADLINE: <2018-10-16 Tue> SCHEDULED: <2018-10-15 Mon>
***** SUBMITTED Take Home QUIZ (ADC, interrupts)
	  DEADLINE: <2018-10-24 Wed> SCHEDULED: <2018-10-23 Tue>
***** SUBMITTED Study for exam 2
	  SCHEDULED: <2018-10-24 Wed>
	  - [0/6] Create Note Sheet with the following information
		- [ ] Reef polling review
		- [ ] Look through lecture (you should understand) bullets
		- [ ] Bit manipulation (putbit, getbit)
		  - [ ] See notes on topic for comprehensive overview
		- [ ] Read through chapter summaries
		- [ ] ADC calculations
		- [ ] Include relevant notes from prior exam notesheet
*** Lab
**** Notes
**** Assignments
** Math307
*** Lecture
*Encryption CANNOT be larger than the modulus -- remember for Final*
**** Key Exchange Protocol
***** Notes
Public INformation:
	- P - Large Prime
	- Q - (Random) number < P

      | # | Alice                                 | Bob                                   |
      |---+---------------------------------------+---------------------------------------|
      | 1 | Choose a random number A (secret)     | Chooses a random number B (secret)    |
      | 2 | Computes A*=Q^A mod p -> A* (public)  | Computes B* = Q^B mod p <-B* (public) |
      | 3 | Computes (secret) DHSA = (B*)^A mod p | (Computes (secret) DHSB=(A*)^B mod p  |
	  
	  Claim: DHSA = DHSB
	  Proof:
	  	DHSA 	= (B*)^A mod p
				= (Q^B mod p)^A mod p
				= (Q^B)^A mod p
				= (Q^A)^B mod p
				= (Q^A mod p)^B mod p
	  	    	= (A*)^B mod p = DHSB

Why is this secure?
It based on *Discrete Log Problem*: We don't know the powers (not related to factoring)
DHS		= (B*)^A mod p, A=?
DHS		= (A*)^B mod p, B=?

**** RSA
***** Notes
****** Key Generation
Key Generation
 1. Choose two primes p,q and compute:
    n=p*q
    phi(n)=(p-1)*(q-1)
 2. Choose a 'random' number t such taht gcd(x,phi(n))=1
 3. Compute e=t^-1 mod phi(n) (t=e^-1 mod phi(n))
	
Public Key:		(n,e)
Private Key:	(t, phi(n))

*RSA ENCRYPTION*
E=M^e mod n
E=ciphertext of M

*RSA DECRYPTION*
M=E^t mod n

*MISC*
e=t^{-1} mod phi(n)
t=e^{-1} mod phi(n)
e is public
phi(n) is private

*FACTORING PROBLEM*
Given n that is a product of two primes, find its primes
****** Signatures
	   - Confidentiality
	   - Data integrity
	   - Authentication
	   - [[https://searchsecurity.techtarget.com/definition/nonrepudiation][Non-repudiation]]
		 - is the assurance that someone cannot deny something.
******* Define ownership of an RSA Key
		terse: signed with private key, verified with public key

		1. The key owner chooses two prime numbers, /p/ and /q/
		2. The key owner compute ~n=p*q~ and ~phi(n)=(p-1)*(q-1)~
		3. The key owner chooses an /e/ with ~gcd(e/phi(n))=1~
		   1. Compute ~e=t^-1 mod phi(n)~
		4. The key owner computes ~t=1/e mod phi(n)~
		
		[[./img/PhiEx.jpg][Whiteboard example]]
		
		The public signature key is ~(n,e)~ 
		The private signature key is ~t~

******* Verify Ownership
		- ~S=M^t mod n~
		  - S is a signature on M
		- ~k=S^e mod n~
		- If k=M, then the signature is valid
****** Attacks
******* COMMON MODULUS ATTACK
Suppose that same message M < n is sent to two different parties whose
encryption exponents respectiveily are e_1 and e_2 and suppose that gcd(e1,e2)=1

 - Assume gcd(e1,e2) = 1
 - gcd(a,b) = a*x + b*y
   for some x,y belonging to Z
 - Using the extendid Euclidean algorithm one can find x and y such that:
   1 = gcd(e1,e2)=e_1 * x + e_2 * y
 - The original message can be found by:
   E^x * F^y mod n 
   = ((M^{e_1} mod n)^x * (M^{e_2} mod n)^y) mod n
   = (M^{e_1})^x * (M^{e_2})^y mod n
   = M^{e_1 * x + e_2 * y} mod n 
   = M^1 mod n 
   = M

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

The encrypted messages are: 
E=M^{e_1} mod n  	(Alice)
 and 
F=M^{e_2} mod n		(Bob)

******* COMMON ENCRYPTION EXPONENT
/assume same people and messages as above/
Assume that gcd(n_1,n_2)=1
Plaintext:	M < n1,n2
E_1=M^e mod n_1	(Alice)
E_2=M^e mod n_2	(Bob)

Using CRT we can solve 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 for M.
 
 M is the unique solution of 
	E_1=M^e mod n_1	
	E_2=M^e mod n_2	
 modulo n1*n2
 	M mod n1*n2 = M because M <n1,n2

	*CHINESE REMAINDER THEOREM (CRT)*
	let n1, n2, ... , nk be natural numbers such that for i,j distinct incices one
	has gcd(ni,nj)=1

	then the system of linear congruences has a solution which is unique modulo:
		N=n1*n2*..*nk
		
    Solution: x=b1*N1*x1 + b2*N2*x2+...+bk*Nk*xk mod N
    where Ni=N/ni and xi=(1/Ni) mod ni
******* COMMON MODULUS ATTACK (Directory Attack?)

| Alice    | Bob      |
|----------+----------|
| n_1, e_1 | n_2, e_2 |
| t_1      | t_2      |

n1 != n2

If gcd(n1,n2) = d > 1
	this means that n1 and n2 share more than 1 factor (other than 1|N)
	then d is one of the primes of n1 *and* n2
******* DOUBLE DUTY ATTACK
		- Assume that /Alice/ uses the same RSA key for encryption AND signature
		- Knowing the same key is used for encryption and signature, we can decrypt the ciphertext E
		  1. Choose a random number /b/
		  2. Compute ~x=b^e * E mod n~
		  3. request /Alice? to sign x
		  4. Let /y/ be the signature on /x/. Compute ~y/b mod n~
		  5. claim y/b mod n = M

Proof of claim (5)
REMEMBER:
~e=t^-1 mod phi(n)~
~e*t = t*t^-1 mod phi(n)~
~e*t = 1 mod phi(n)~
~e*t mod phi(n) = 1~

~y/b mod n = (x^t)/b mod n~
		  ~= (b^e * E)/b mod n~
		  ~= ((b^{e*t})/b) * E^t mod n~
		  ~= ((b^{e*t mod phi(n))}/b) * E^t mod n~
		  see REMEMBER above
		  ~= (b^1)/b * E^t mod n~
		  ~= 1 * E^t mod n~
		  ~= E^t mod n = M~
******* Chosen Ciphertext Attack(Signature Forging)
		- This attack can be used to forge a signature on a message
******** M-coded message
		- Compute factorization of:
		M= p1^{m1} * p2^{m2}*...*pk^{mk}
		- Requests that bob sign p1,p2,p3,....,pk
		- Assume that Q1,Q2,Q3,...,Qk are corresponding signatures..
		CLAIM: Q1^{m1}*Q2^{m2}*....*Qk^{mk} is Bob's signature on M

		(n,e) - Bob's public signature key
		Q1=P1^t mod n (Q1 is a signature on p1)
		Q2=p2^t mod n
		.
		.
		.
		Qk=pk^t mod n : where t is Bob's private signature key

******** RSA verification:
			____SIGNATURE_____
		(Q1^{m1}*Q2^{m2}*....*Qk^{mk})^e mod n = M
		(Q1^{m1})^e *(Q2^{m2})^e *....* (Qk^{mk})^e mod n = M
		((P1^t mod n)^{m1*e}) *((P2^t mod n)^{m2*e}) *....* ((pk^t mod n){mk*e}) mod n = M
		(p1^{t*e})^m1 * (p2^{t*e}})^m2 *...* (pk^{t*e})^mk mod n
		REMEMBER: t=e^-1 mod phi(n) --> t*e= 1 mod phi(n)
		(p1^{t*e mod phi(n)})^m1 * (p2^{t*e mod phi(n)}})^m2 *...* (pk^{t*e mod phi(n)})^mk mod n
		(p1^1)^m1 * (p2^1)^m2 * ... * (pk^1)^mk = M
		^
		This shows that Q1^m1 * Q2^m2 *....*Qk^mk is a valid signature on M
#+NAME: CipherText worked out
#+BEGIN_EXAMPLE 
#+END_EXAMPLE
******** Example
#+BEGIN_EXAMPLE 
M=12=2^2 * 3
Bob's public signature key (n=15,e=7)

15=3*5, phi(15)=(3-1)(5-1)=12
t=7
e= t^-1 mod 8
e= 7^-1 mod 8
e=7

1. We will show how Eve can forge Bob's signature on M=12
2. Eve asks Bob to sign p1=2 and p2=3
3. Bob signs p1=2: 2^7 mod 15 = 8
4. Bob signs p2=3: 3^7 mod 15 = 12
   - 8 is Bob's signature on 2
   - 12 is Bob's signature on 3
5. Eve computes the following:
   - 8^2 * 12^1 mod 15 = 3
   - We claim that 3 is a valid signature on M
6. Too show this we need to use RSA verifiction algorithm
   - S = 3; a valid signature
   - if S^e mod n = M, S is a valid signature on M
   - Compute 3^7 mod 15 = 12 *Verified!


#+END_EXAMPLE
******* Fermat's Factoring Method
******** See Sage:fermatAttack.sagews for example
******** Attack
		- Theorem (Fermat) Every odd integer (positive)
		  can be represented as difference of squares
		  - n=X^2-y^2 = (x-y)(x+y)
		- Fermat's attack is a deterministic factoring method
		  - not probabilistic?
		- Assume that n is RSA modlus. This means
		  - p=x-y and q=x+y
		  - p+q = 2x -> x=(p+q)/2
		  - q-p = 2y -> y=(q-p)/2
		  - n = x^2 - y^2 -> y^2=x^2 -n
			- y^2 >= 0 implies x^2 >= n  implies x >= sqrt(n)
		- Method
		  1. x= floor(sqrt(n))
		  2. check floor(x)^2 - n is a perfect square
			 1. if yes, we are done
				1. sqrt(floor(x)^2 -n)) = y
				2. floor(sqrt(n))=x
			 2. if not x->x+1
				1. x=floor(sqrt(n))+1
				2. Check whether floor(x)^2 - n is a perfect square
				   1. If yes we are done.
				   2. Otherwise x->x+1 and repeat
******** Defence
		- find p*q=n such that Fermat's factoring method is computationally difficult
		- Misc
		  - x=sqrt(n) +1
		  - x^2 - n = y^2
		  - (sqrt(n) + 1)^2 -n = y^2 (?)
		  - .
		  - .
		  - .
		  - (sqrt(n) + m)^2 - n = y^2

		- Defence against
		  1. If we have {p=x-y; q=x+y}, x=(p+q)/2, y=(q-p)/2
		  2. Using simple algebra...we get
			 - m=(sqrt(p) - sqrt(q))^2 /4
		  3. m is "small" if p~=q
		  4. DEFENSE: Choose p and q such that m is "large"
		
********* Example
********** Misc
		  1. Assumee that after k many iterations we find
			 1. x=sqrt(n) +k and y=sqrt(x^2 -n)
******* Initial Segment Factoring Method
******** IS attack explained
		 - R - RSA modulus
		 - R has n digits
		 - Consider: ~x_j = (R-(Rmod 10^j))/10^j for j < n~
#+NAME: IS attack (proof)
#+BEGIN_EXAMPLE 
R=12351 //Number to find factors of
n=5 //Number of iterations

j=1 : x1 = (12351-(12351 mod 10))/10
REMEMBER: 12351 = 1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4
12351 mod 10 	= (1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4) mod 10
12351 mod 10 	= 1*10^0 mod 10 + 5*10^1 mod 10 
					+ 3*10^2 mod 10 + 2*10^3 mod 10 + 1*10^4 mod 10 
				= 1 + 0 + 0 + 0+ 0 = 1
x1				= (12351-1)/10 = 12350/10 = 1235
x1 is the first four digits of R

j=2 : x2 = (12351-(12351 mod 10^2))/10^2
REMEMBER: 12351 = 1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4
12351 mod 10 	= (1*10^0 + 5*10^1 + 3*10^2 + 2*10^3 + 1*10^4) mod 100
12351 mod 10 	= 1*10^0 mod 100 + 5*10^1 mod 100 
					+ 3*10^2 mod 100 + 2*10^3 mod 100 + 1*10^4 mod 100
				= 1 + 50 + 0 + 0+ 0 = 1
x2				= (12351-51)/10 = 12300/10 = 123
x2 is the first three digits of R

xj is the first n-j digits of R
Because R is the product of 2 primes, the first gcd > 1 will be a prime factor
for some j, gcd(R,xj) = q
#+END_EXAMPLE
******** Defence:
		 1. Check whether n is weak against Fermat Attack
			- n i sresistant against Fermat Attack
		 2. Choose primes p and q such that p has some number of
			consecutive zeroes and choose q such that #q is alrger than
			the number of zeroes in p
		 3. Compute N=p*q
		 4. Apply IsAttack on N and Fermat Attack on N
******* One Line Factoring and partial Key Exposure Attack (Similar to Fermat)
******** Method
		1. Compute s= ceil(sqrt(n))
		2. Compute m = s^2 mod n
		3. Check whether m is a perfect sqaure
		   - If yes, compute t= sqrt(n). then gcd(s-t,n)=p
		   - if not increase i and go to step 1
******** Analysis
		 - Assume that n=p*q has prim factors n^1/3 < p, q < n^2/3
		 - view Slides on own time to see the proof
		 - O(cube_root(n)) with probability greater than .5
******* Partial Key Exposure Attack
******** Attack
#+NAME: Why it works (Partial Key Exposure Attack Proof)
#+BEGIN_EXAMPLE 
Ex1:	
	5 = 2 mod 3
	5 = 1*3 + 2
Ex2:
	17 = 2 mod 3
	17 = 5*3 + 2
Ex3:
	d = e mod n
	d = n*k + e :for some k

d 	= 1/e mod phi(n)
d*e = 1 mod phi(n)
e*d	= k*phi(n) + 1
UNKNOWNS:	phi(n),k,d
KNOWNS:		n,e
"Well-Known" AM-GM inequality shows:
	2sqrt(xy) <= x + y
! This can be used to approximate phi(n)
	phi(n) 	= (p-1)(q-1)
			= pq - (p+q) + 1 <= pq - 2sqrt(pq) + 1
			<= n - 2sqrt(n) + 1
			*Note equality sign flipped by mult. of -1
	e*dk	= k*phi(n) + 1 //where Dk is smoe approximation of d (private key)
		therefore
	*For k < d define:
	Dk 		= (k*phi(n) + 1)/e //note that phi(n) is our approximation as shown above
	
	if we have the last m digits of d, (Least significant portion), we can
	substitute L (least significant portion) to improve our approximation
	of Dk by replacing the LSD (Least Significant Digits) of Dk with L.
	
#+END_EXAMPLE

#+NAME:  Partial Key Exposure Attack
#+BEGIN_SRC sage
########################################################################################
# The function takes in the requested inputs and computes a decryption key             #
# If there are not enough digits in the input the function will tell you so            #
########################################################################################

def partial (R, e, partd):
    m = 1000
    E = m.powermod(e,R)#&^(m, s) % R
    for k in range(1, e * 10000):
        Dk = math.floor((k * (R - 2 * isqrt(R) + 1) + 1) / e)
        l=(partd).ndigits()
        Dk=Dk-(Dk % 10^l)+partd
        mm = E.powermod(Dk,R)#E&^Dk mod R:
        if m == mm:
            return(Dk)
    print("not enough digits to discover d")

R=1030794365305576815134103206958049837943419896523;
e=17873;
partd=6816907735531628355014100526810177;
Dd=partial(R,e,partd);
Dd

p = next_prime(776213649127364987123648972364987123648972316498623197124356715324065713526)
q = next_prime(2345545654565456654512374619287364981723648972163984612983461912386)
N = p*q
phiN = (p-1)*(q-1)
e = 17
e
while gcd(e,phiN)!=1: e+=1
d = 1/e % phiN
d
partialD = 1452930806742028080905133750698038297318124171383735131021465946217038961017925194270324213877445652376073
Dd=partial(N,e,partialD);
Dd
#+END_SRC

#+RESULTS: Partial Key Exposure Attack
: not enough digits to discover d
: 17
: 749677168357388769334958802538629561452930806742028080905133750698038297318124171383735131021465946217038961017925194270324213877445652376073
: not enough digits to discover d

******** Defence
		 - Retain MSD (Most significant digit)
		 - Split into different ways (every other digit, every 3rd digit)
		 - Split into several parts
****** CRT (Chinese Remainder Theorem)
******* Notes
M1= x mod n1
M2= x mod n2
M3= x mod n3
M4= x mod n4
M5= x mod n5

M1,M2,M3,M4,M5 - cipher texts
			M - plaintext
			M - ?
			x = M^e - not known
To find x we will use the CRT
When we find x we compute x^(1/e)
******* Example
#+NAME: CRT
#+HEADER: :tangle ./src/sage/crt.sage
#+BEGIN_SRC sage
#################################################################################################
# The input is a number and the output is the original message. If the input is not padded ASCII#
# version of a message it returns the value: "This is not a padded ASCII string"                #
#################################################################################################
def ASCIIDepad(Number):
    ndigits=len(str(Number))
    n = ndigits % 3
    if (n > 0):
        print("This is not a padded ASCII string\n")
    else:
        L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)]
        N = ""
        for i in range(Number.ndigits()/3):
            N = chr(L[i]) + N
        return(N)

b=[
17089298199140245689054146396696610382482599563869128220501355545433181167922449,
647456570985467791350694143163125775416153692645317710289110387858313344490925,
1571157443614188818570414758920219335869445581270513124197983268054945711653,
8680494616758492300153857128626182886244875669712992627620622363379875255673298873890889, 
3740176144174317705113182325751346003703203506734421120250951010374481407984708481673873
]
# encryption canNOT be larger than the modulus
n=[
138167915492481816745409346812614907970213601388948993432404324912548722779337539,
689234730968542058710415199123628060022111911748855188203650454001478717930441,
165927789907443292785652054606917804467309174081946624778696246358960638705571,
9707030033411217539906954498964338207893718488045203990403325340285676761140144260245667,
9702513696679623002778707839853209062395283481756367743103770927153046936810417007760591
]

e=5
x = crt(b,n); x
M=x.nth_root(e)
M=ASCIIDepad(M)
M
#+END_SRC

#+RESULTS: CRT
: 179702189046065030137840983877506282733808216772222487872385030013418159775151368010537808270369776111280249922696184622250812210618422156974500421843302635815511055022781078203555271102862470424542573876078160729973527171345068730365265430297970391004390643094550260335823552446001
: 'Next hack DigiCrime'

***** Examples
****** Attacks:COMMON MODULUS ATTACK (Directory ATTACK?)
From Sage:
#+BEGIN_SRC python

# an example of rsa common modulos attack
# (1) Choose three large primes
p=next_prime(16718273096520398462809571209865120938651029871098236409287109865983649721650123640975210352)
q1=next_prime(1092836510928346091832650987120398470239861059836018923750892136509812349086230985709128349)
q2=next_prime(1230519283509213864092710983561209836590218364921836509827340892370561029309871423498021350)
# (2) Compute n1=p*q1
#             n2=p*q2
n1=p*q1
n2=p*q2
# (3) Computer phi1=(p-1)*(q1-1)
#              phi2=(p-1)*(q2-1)
phi1=(p-1)*(q1-1)
phi2=(p-1)*(q2-1)
# (4) Choose two random numbers t1, t2 such that:
#                 gcd(t1,phi1)?=1
#                 gcd(t2,phi2)?=1
t1,t2=31,next_prime(1024)
while(gcd(t1,phi1)!=1):
    ++t1
while(gcd(t2,phi1)!=1):
    ++t2
# (5) Compute:
#      t1^-1 mod phi1
#      t2^-1 mod phi2
d1=inverse_mod(t1, phi1)
d2=inverse_mod(t2,phi2)

#Directory Attack:
x=xgcd(n1,n2)
print(x[0]) #Calculated prime gcd(n1,n2)=p
print(p)    #Original prime

#+END_SRC
****** ATTACKS: ISATTACK
#+NAME: InitialSegment Attack Small q
#+BEGIN_SRC sage
def ISAttack (R):
    n = R.ndigits()
    #n = len(R)
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"

# Choose large prime with many consecutive zeros
p=next_prime(1213000000000000000000000000000000000000000000000000000000000000124)
p
# Choose prime with less digits than p has zeros
q=next_prime(1234567890)
q
# COmputer n=p*q
n=p*q
n
# Apply ISAttack
p=ISAttack(n)
p
#+END_SRC
#+RESULTS: InitialSegment Attack
: 1213000000000000000000000000000000000000000000000000000000000000291
: 1234567891
: 1497530851783000000000000000000000000000000000000000000000000000359259256281
: 1234567891

#+NAME: InitialSegment Large q
#+BEGIN_SRC sage
def ISAttack (R):
    n = R.ndigits()
    #n = len(R)
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"

# Choose large prime p with many consecutive zeros
p=next_prime(1000000000000000000000000000002347239472938749237492837498237984237987237498792831)
p
# Choose large q
q=next_prime(196327349823794238791247612374689213649218736498)
q
# Compute n=p*q
n=p*q
n
p=ISAttack(n)
p
#+END_SRC
#+RESULTS: InitialSegment Large q
: 1000000000000000000000000000002347239472938749237492837498237984237987237498793079
: 196327349823794238791247612374689213649218736623
: 196327349823794238791247612375150040954342600855043086369924757982661461133718474657040466537331025478920476913721120235676232217
: nonefound
**** Dirichlet Algorithm (Primitive Roots)
#+NAME: DA
#+BEGIN_SRC C
def Dirichlet (q):
    j=0
    #for j in numpy.arange(0.10e1, infinity + 0.10e1, 0.10e1):
    while True:
        j+=1
        p = 2 * j * q + 1
        if is_prime(p) == True:
            return(p)

def findLargePrimitiveRoot(n,p):
    n=n+1
    eulerp = euler_phi(p)
    Q = list(factor(eulerp))
    while n<p:
        found = True
        for Q2 in Q:
            q=Q2[0]
            totest = power_mod(ZZ(n),ZZ(eulerp/q),ZZ(p)) 
#            print(totest)
            if totest==1:
                found = False
        if found:
            return n
        n+=1
#+END_SRC
**** Diffie-Hellman key exchange protocol
***** Notes
***** Example
#+NAME: Diffie-Hellman
#+BEGIN_SRC sage
def Dirichlet (q):
    j=0
    #for j in numpy.arange(0.10e1, infinity + 0.10e1, 0.10e1):
    while True:
        j+=1
        p = 2 * j * q + 1
        if is_prime(p) == True:
            return(p)

def findLargePrimitiveRoot(n,p):
    n=n+1
    eulerp = euler_phi(p)
    Q = list(factor(eulerp))
    while n<p:
        found = True
        for Q2 in Q:
            q=Q2[0]
            totest = power_mod(ZZ(n),ZZ(eulerp/q),ZZ(p)) 
#            print(totest)
            if totest==1:
                found = False
        if found:
            return n
        n+=1

# (1) Choose a large prime p
# REF: https://stackoverflow.com/a/34141119
p=random_prime(10**150,10**160)
p
# (2) Choose a primitive root Q of P
# 	- the smalles number k such that Q^k mod P = 1 is (p-1)
# REF: http://doc.sagemath.org/html/en/prep/Quickstarts/Number-Theory.html
#q=mod(primitive_root(p),p)
#q

#a=randint(1,p) # Alice's random number
#b=randint(1,p) # Bob's random number
#x=q**a; y=q**b
#x; y; x**b; y**a

#x=findLargePrimitiveRoot(10**10,p)
#x
x=mod(Dirichlet(p),p)
x
#+END_SRC

#+RESULTS: Diffie-Hellman
: 729997630957051815181242080946878121063643194794671653097237700984266810608325417858611624412093730804217338385338030978454365100508284340524035090477
: 7
: 472020484402767
: 395319770560594
: 249234316520562
: 249234316520562
: 10000000001

**** El Gamal Public Key Cryptosystem
***** About
****** Key Generation
	   1) Choose a large prime ~p~ and number ~g < p~
	   2) Choose a random number ~x~
	   3) Compute ~b=g^x mod p~
		  - Public Key: ~p,g,b~
		  - Private Key: ~x~
****** Encryption
	   1) Choose a random number ~r < p~
	   2) Choose a primitive root 1 < g< p
	   3) Choose a random number x
	   4) Computer b = g^x mod p
		  - public key: (g,b,p)
		  - private key: x
		  - pair (y1,y2) is the cipher text

****** Decryption
	   1) Compute D= y2*(y1)^-x mod p = M mod p
	   2) see slides for proof
****** Signature
	   1) Choose a random number r < p-1 and gcd(r,p-1) = 1
	   2) Compute g^r mod p = y
	   3) Compute
		  S = (M-x*y)/r mod (p-1)
		  *Signature on M is the pair y,s*
****** Verification
	   v1=y^s * b^y mod p
	   v2=g^M mod p
	   verified if v1==v2
		
***** Attacks on El Gamal
****** Random Number Attack on El Gamal Signature
	   1) Assume that ~r1=r2~ are used in signing two different messages ~M1, M2~

          | Signing M1               | notes        | Signing M2               |
          |--------------------------+--------------+--------------------------|
          | g^r1 mod p = y           | r1=r2        | g^r2 mod p = y           |
          | S1=(M1-x*y)/r1 mod (p-1) | S1!=S2;r1=r2 | S2=(M2-x*y)/r2 mod (p-1) |
          |                          |              |                          |
		  				\												   /
						 \										   		  /
							| Signing both M1, M2                       |
							|-------------------------------------------|
							| S1*r1=M1-x*y mod (p-1)                    |
							| S2*r2=M2-x*y mod (p-1)                    |
							| DENOTE r=r1=r2                            |
							| S1*r=M1-x*y mod (p-1)                     |
							| S2*r=M2-x*y mod (p-1)                     |
							| r=(M1-x*y)/S1 mod (p-1)                   |
							| r=(M2-x*y)/S2 mod (p-1)                   |
							| (M1-x*y)/S1 = (M2-x*y)/S2 mod (p-1)       |
							| (M2-x*y)*S1 = (M1-x*y)*S2 mod (p-1)       |
							|                                           |
							| S1-S2 = (M1-x*y)/r - (M2-x*y)/r mod (p-1) |
							| S1-S2 = (M1-M2-x*y+x*y)/r mod (p-1)       |
							| S1-S2 = (M1-M2)/r mod (p-1)               |
							| r=((M1-M2)/(S1-S2) mod (p-1)              |
		  1) P = prime number (public)

		  2) S1,S2 (public)

		  3) M1,M2 (public)

		  4) r (secret)

		  5) Eve will compute r by computing (m1-M2)/(S1-S2) mod (p-1)

		  6) Solve for x (private key) by solving
			 - S1=(M1-x*y)/r mod (p-1)
		  	 - x=(M1-S1*r)/y mod (p-1)
		  7) Note: Sometimes linear congruence has more than one solution
			 - if gcd(S1-S2,p-1) = d >1, then the equation (S1-S2)*r = 1-M2 mod (p-1) has more than one solution (in fact it has d many solutions)
			 - use ~g^ri mod p =y~ to find an ~r~ that satisfies the equation
		  
****** Covert Channel on El Gamal Signature
******* Notes
	   1) Assume that the private key x is 160 bits long. (160 is the chosen standard for this example. Any standard  can be used)
	   2) x^2 mod p = a
	   3) We say that a is a quadratic residue (QR) of p if (2) has a solution
		  - (a/p) = 1 if a is a QR of p
		  - (a/p) = -1 otherwise
		  - (a/p) is called the Legendre Function
		  - (a/p)* = ((a/p) + 1)/2
			- (a/p)* = 1 if a is a QR
			- (a/p)* = 0 otherwise
	   4) Public Key: b,g,p (b=g^x mod p)
	   5) Private key: x
	   6) p1,p2,p3,...,p13,p14 = primes
	   7) Blocks
		|----+----+-----+-----|
		|    |    |     |     |
		| B0 | B1 | ... | B15 |
	   8) Bi = 10 bits
	   9) P1,p2,...,P10 - leak the content of Bi
		  - concat((y/p1)*, (y/p2)*,...,(y/p10)*) - represents binary number
	   10) p11,p12,p13,p14 - leak the block number
		   - concat((y/p11)*,(y/12)*, (y/13)*, (y/14)*) - represents binary number

	   11) Key x is 160 bits
	   12) Size of each block of x is 10 bits
	   13) The number of blocks in x is 16

******* Example
#+NAME: Legendre Covert Channel
#+BEGIN_SRC sage
##############################################################################################################
# We want to discover a private key of at most 160 bits from signatures using a Legendre-type covert channel.#
# We have 14 covert primes, and 16 signatures which reveal 16 blocks of 10 bits each about the private key.  #
##############################################################################################################
def NewLegendre(a,p):
    if is_prime(p):
        return (1+kronecker(a,p))/2
    else:
        print "2nd argument has to be a prime"
        
def BlockNumber(y,primelist):
    m=0
    for i in xrange(0,4):
        m = 2*m + NewLegendre(y,primelist[i+10])
    return m+1

def BlockContents(y,primelist):
    k=0
    for i in xrange(0,10):
        k=10*k+NewLegendre(y,primelist[i])
    return k

def KeyDiscover(ylist,primelist):
    c=10^10
    k=0
    for i in xrange(16):
        d=16-BlockNumber(ylist[i],primelist)
        k=k+(BlockContents(ylist[i],primelist))*(c^d)
        #k=k+(BlockContents(ylist[i],primelist))*c^d
    return int(str(k),2)

y=[0]*17
s=[0]*17
p=[0]*15
y[1]= 6355654156581339292380028178295946379397857230419335473049773634105011
s[1]= 3560725073968654220540577725166322807481561312157414571860157629465222


y[2]= 6157738735079726271974947267390448530039834693941568486254984166399169
s[2]= 6291144800430142601833562065314744488661843993287483337500999473866049



y[3]= 9335313663168312334842734241780762294755281133475486862667663109265693
s[3]= 1031174004049088397035651840893708758323829943237917442328886035203304


y[4]= 5666312454503499142803478855324287143700047631332918051757975784387852
s[4]= 7474462038392337038267162594316747902979250709302501061852809955557686



y[5]= 8609729555305475123927447895155480568383891784974360653476349663970219
s[5]= 9392131610200414588504854275564189165850448855170937440564772246654800



y[6]= 7365404439138911411864937298776875814102498525963049435105763372378772
s[6]= 647447785466753660592038806991306978403341150904526358877367886003642



y[7]= 5705440343386587753765002035968279773205391692599442025007820809081663
s[7]= 7706884617942615865555527903233116366329368354497449630894822636431727



y[8]= 9139181219517140532824520580591540432442737355121485514849816985670182
s[8]= 9119886852416426951627821313728462871487106020439368341742027870361688


y[9]= 3851953190357247351746340095276683473382065321260493360272121028908078
s[9]= 5799995345355474114152639857813718721964327387996505577731360092639224



y[10]= 8332119728236605996252741802820164399490394892793656670206410123540806
s[10]= 3382049014239536347193207790839121703028337382022833734591171852421851


y[11]= 1090916439028367923335435833686239225083325662650219511577614470087626
s[11]= 784467849834343142005625314726078169629151138271180139914842146743784



y[12]= 4044337428348522271547535017777415980322724356426081427629324943634693 
s[12]= 875430208213556723165929030182187434842223658973047200347756281547097


y[13]= 5047503978916103346914776520107614498353295441864520623517103573476005
s[13]= 8856726072244904117515011381053001354515613401207356043353782820904450



y[14]= 3079609686866100016134750688150613028636970390199280613932162055042282
s[14]= 2910381948910080172894739786204355803866267753930250967405306509357624



y[15]= 2507949926452818146783101167935559217583543852145717090862513023080430
s[15]= 2448150721429647913194335461249415499372183912050199930744663457020240


y[16]= 1137237284834714268920432440084126521105380025168123492652543171722168
s[16]= 9770021075461804348672365094369599228327792685910556392116440254449953


p[1]=2610874309742867231360502542308382199053675592825240788613991898567287
p[2]=6881793749340807728335795394301261629479870548736450984003401594706373
p[3]=8314906195914825136973281314862289454100745237769034410057080703111511
p[4]=5127114594552921209928891515242515620324828055912854227507525717981667
p[5]=7473570262981491527797413449568788992987500442157627511097882499376811
p[6]=9062890227065912603127119521589474574157513825150650905007553408748219
p[7]=2815984929359632269852681585809504709739738485231104248045693804710167
p[8]=8302655538010818866476054310788175542136407374106205605523687223947057
p[9]=5812242019121022573901665288968349097396414947780422731613987785640429
p[10]=4198272844134050365811754869582636140810856859347877704841433599229643
p[11]=8724880795485531802023255050614524952922474293642065329619154912668053
p[12]=6069438450681407641506962917791070874166946435905950292905549552889463
p[13]=4125842236067060541266621757734462223575905687273574099511410424381497
p[14]=9501247275887974857856234450269247606386273485070460241146322057229349

#################################################################################################
# ylist - This is the list of y's from the signatures given in the form ylist =[y1,y2,....,y16] #
# primelist - This is the list of coverts primes given in the order they appear in the program. #
# It is given in the form primelist =[prime1,prime2,....,prime10,prime11,...,prime14]           #
#################################################################################################


ylist = [0]*16  #Steps down indexing from 1-16 down to 0-15.
for i in xrange(16):
    y[i]=y[i+1]
    ylist[i]=y[i+1]
    s[i]=s[i+1]
print ylist

primelist = [0]*14
for i in xrange(14):
    primelist[i]=p[i+1]
for i in xrange(14):
    p[i]=p[i+1]
    primelist[i]=p[i+1]
print primelist


len(primelist)
testout = KeyDiscover(y,p)
print testout

BlockNumber(y[0],p)

BlockContents(ylist[0],p)

for i in xrange(16):
    bc = BlockContents(ylist[i],primelist)
    print (BlockNumber(ylist[i],primelist),bc,)
#+END_SRC

**** Iterated Encryption
***** Iterated encryption security
#+BEGIN_EXAMPLE 
E1=M^e mod n
E2=E1^e mod n
E3=E2^e mod n
E4=E3^e mod n
.
.
.
Ek-1=E(k-2)^e mod n
Ek=E(k-1)^e mod n


BUT....
Ek			=	((E(k02)^e)^e mod n) mod n
			=	(E(k-2)^e^2) mod n
			=	(E((k-3)^e)^e^2) mod n
			=	(E(k-3)^e^3) mod n
			.
			.
			=	(E1^e^(k-1)) mod n
			=	((M^e)^e^(k-1)) mod n
			=	(M^e^(k)) mod n
#+END_EXAMPLE
***** Euler's Theorem
	  - m<n , gcd(m,n)=1
	  - m^phi(n)  mod n = 1
***** Fermat's Theorem
#+BEGIN_EXAMPLE 
Ek	=M^e^k mod n
	=M^(e^k mod phi(n)) mod n

if e^k mod phi(n) = 1, then
Ek = M
#+END_EXAMPLE
***** Carmichael Function
	  - lambda(n) is the smallest integer m such that a^m _= 1 mod n
	  - if n is > 0, and a is pos int coprime to n then a^lambda(n) mod n = 1
#+BEGIN_EXAMPLE 
Ek = M^e^k mod n
e^k mod lambda(n) = 1
:e^k = t * lambda(n) + 1

Example: 	5 mod 3 = 2
			5 = 1*3 + 2
Example: 	7 mod 3 = 1
			7 = 2*3 + 1
e^k 	= t * lambda(n) +1
M^e^k	= M^t*lambda(n) + 1 mod n
		= M^t*lambda(n) * M) mod n
		= ((M^lambda(n))^t mod n) * M mod n
			^^
		 1^t (carmichael's thm)
		= M
#+END_EXAMPLE
**** Socio-Technical Ethics & Morality (Donald Winecki)
***** STEM are (not) /JUST/ Technical
****** Algorithmic Bias in Criminal Justice
******* Book: "Weapons of Math Destruction" - problems in security/algorithms
******** Kathy O'Niel
******* Book: "Raw Data is an oxymoron" 
****** Socio-economic status valid predicter of race!?
*** In-Class Examples/Practice
#+NAME: Iterated Encryption
#+BEGIN_SRC sage

# RSA - Encryption Procedures=========
def rsaencrypt(Message, encrexp, encrmod, rounds):
    if (rounds <= 0): return Message
    A=Message
    E = power_mod(A,encrexp,encrmod);
    return rsaencrypt(E,encrexp,encrmod, rounds-1)
#=====================================

# Blackboard:LectureNotes:Lecture11:Example
# REMEMBER: E1=M^e mod n
# Where M-plaintext and E-ciphertext
# ^^ 1st encryption vv 2nd encryption
# E2=E1^e mod n

# Encryption Modulus:
n=315562173921131111550753275258954314886929684614433857059068225329589007516900986203500713113234143069878550293
# Encryption Exponent:
e=1835588100642725811278316299646156385857628660058608776628872255463681001129596115865795858135978837517124882698892069345209251312769967638417909171551219459094621692202465346003400944724101186482909006146466321559204641
# Ciphertext:
E=150598315159426420417362370315760759643687452249127260593893330249875774660837569082216166241764228321707042114

E=rsaencrypt(E,e,n,10)
E
#+END_SRC

#+RESULTS: Iterated Encryption
: 150598315159426420417362370315760759643687452249127260593893330249875774660837569082216166241764228321707042114

#+NAME: Hellman Pohlig Silver Attack
#+BEGIN_SRC sage
import itertools
def HPSonP (Generator, Target, P):
    Unknown = 0
    N = P - 1
    K = factor(N)
    K = list(K)
    #print K
    for pk in K:
        #print pk
        primes =pk[0]
        #Maple code to convert
        #primes = op(1, op(1, op(i, K)))
        #if len(K[i]) == 1:
        #if len(op(i, K)) == 1:
        #    powers = 1
        #else:
        #    powers = op(2, op(i, K))
        powers = pk[1]
        Z = N / primes
        chi = power_mod(int(Generator), int(Z),int(P))
        n = 0
        t = [0]*powers
        a = [0]*powers
        d = [0]*powers
        for j in xrange(0, powers):
            #print j
            if j == 0:
                a[j - 1] = Target
            else:
                Z2 = (d[j - 1 - 1] * power_mod(int(primes),int(j - 1),int(N))) % N
                Pt = power_mod(int(Generator), int(Z2),int(P))# % P
                a[j-1] = (a[j - 1 - 1] / Pt) % P
            y = Z / primes ** j
            t[j-1] = power_mod(int(a[j - 1]),int(y),int(P))# % P
            s = 1
            for k in itertools.count(1):
                #print "k",k
                if t[j - 1] == s:
                    d[j - 1] = k
                    break
                s = (s * chi) % P
            n = (n + d[j - 1] * primes ** j) % N
        NN = N / primes ** powers
        X = (1 / NN) % primes ** powers
        Unknown = (Unknown + NN * n * X) % N
    #unassign(t)
    return(Unknown)



def Dirichlet (q):
    j=0
    
    #for j in numpy.arange(0.10e1, infinity + 0.10e1, 0.10e1):
    while True:
        j+=1
        p = 2 * j * q + 1
        if is_prime(p) == True:
            return(p)
        
def findLargePrimitiveRoot(n,p):
    n=n+1
    eulerp = euler_phi(p)
    Q = list(factor(eulerp))
    while n<p:
        found = True
        for Q2 in Q:
            q=Q2[0]
            totest = power_mod(ZZ(n),ZZ(eulerp/q),ZZ(p)) 
#            print(totest)
            if totest==1:
                found = False
        if found:
            return n
        n+=1
		
#(1) Choose a large prime q
q=random_prime(10**15,10**20)
#(2) p=Dirichlet(q)
p=Dirichlet(q)
is_prime(p)
f=factor(p-1); f
#(3) Find primitive root of p
g=findLargePrimitiveRoot(random_prime(10**15,10**20),p); g
#(4) Choose
#  c0 < p1
#  c1 < p2
#  ...
#  ck = q-1
c=[1]
p=[]
for i in range(len(f)):
	c.append(f[i][0])
	p.append(f[i][0])

for i in p:
	print(i)
for i in c:
	print(i)
#crt(c,p)
#+END_SRC

#+RESULTS: Hellman Pohlig Silver Attack
#+begin_example
True
2^2 * 3 * 5 * 610459946299339
579995556223154
2
3
5
610459946299339
1
2
3
5
610459946299339
#+end_example

*** Assignments
**** Homework 6
	 INE: <2018-10-18 Thu> SCHEDULED: <2018-10-15 Mon>
	 ERTIES:
	 IVE_TIME: 2018-11-12 Mon 12:14
	 IVE_FILE: ~/.emacs.d/Notebooks/BSU.org
	 IVE_OLPATH: Fall 2018/Math307/Assignments
	 IVE_CATEGORY: BSU
	 IVE_TODO: DONE
	 
*****ITTED Print off assignment
	 DULED: <2018-10-17 Wed> DEADLINE: <2018-10-18 Thu>
*****tion
   #+ Assignment 6: Fermat Attack
   #+_SRC sage 
   # ion Definitions
   # Blackboard Software (rsadecrypt)
   deIIDepad(Number):
      Number.ndigits() % 3;
     (n > 0):
      print("This is not a padded ASCII string\n");
     e:
      L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
      N = "";
      for i in range(Number.ndigits()/3):
          N = chr(L[i]) + N;
      return(N)

   dedecrypt(encr,decrexp,encrmod):
      power_mod(encr,decrexp,encrmod);
      ASCIIDepad(D);
     urn(N);


   # Blackboard Software Sources (Fermat Attack)
   dert(n):
     urn int(floor(sqrt(n)))

   dert (n):
     = isqrt(n)
     ur ** 2 < n:
      ur = ur + 1
     urn(ur)

   dematAttack (n, rounds):
     = usqrt(n)
      x in range(st, st + rounds + 1):
      #print (x-st)
      sq = x ** 2 - n
      y = isqrt(sq)
      if y ** 2 == sq:
          print "Factor found in round {0}".format(x-st+1)
          return(x + y)
     nt "No factor found in {0} rounds".format(rounds)

   # e Problem information into code
   # Key=(R/n,e) where R or n is the modulos
   aly=(3200909051105364201164693808053590029074088922158723491051061550603549823737458227601881401901569257978004143012923593331603179164497963879113975835000986070024699519343049991253001543465847139349037243656109687211847515003135028132545450689475582835433024130454351048493271288284326740872991312817737068756145723348616748658487242931184584005382638341 ,45938274932874982748938989492800101)
   n=Key[0]
   e=Key[1]
   bo46965299225077453528764533325484870128106736546137408200095456059067040313170132659677309326733627254170824177278689792967869683703210102631692715251241388457103568881887427174337319839702934337074114069079964028787201219122008132800911350242389943062437915595376659222211331548822861710469042657218207369516502014847384607200570429591504554077212313

   #  Fermat Attack on bob's message
   p=tAttack(n,10)
   p
   # the prime factors of n
   q=Key[0]/p
   ph1)*(q-1)

   # te private key
   t=se_mod(e,phi)
   t
	
   # pt to decrypt the message
   D=crypt(bobM, t, n)
   D

   pr\nSolutions:\n")
   prThe message is {}\n".format(D))
   prThe private key is {}\n".format(t))
   prThe value of phi(R) is {}\n".format(phi))
   prFactors of R are {} and {}\n".format(p,q))

   #+RC

   #+TS: Assignment 6: Fermat Attack
   #+_example
   Fafound in round 1
   566876878687676755667454534349837593827932875983275983759382759287237567887987980908998787786767565645454533423423343243546576576876879879879879878687675765644535434287237L
   31510034742237627997195928786583153512307937169989597828968058877017293250922100187347305076307004322384676497222811128113753424625921466939826882160195180303741752185273650841791717876895004244979963739993488694617994141773778317684342636200808646316120457410025841816142247504391080136501066088010574604519661347572707772349904352818684682371437
   'Ity Based Cryptosystems'

   Sons:

   Thsage is Identity Based Cryptosystems

   Thvate key is 31678635100347422376279971959287865831535123079371699895978
   2888770172932509221001873473050763070043223846764972228111281137534246259
   2198268821601951803037417521852736508417917178768950042449799637399934886
   9441417737783176843426362008086463161204574100258418161422475043910801365
   018010574604519661347572707772349904352818684682371437

   Thue of phi(R) is 32009090511053642011646938080535900290740889221587234910
   5106035498237374582276018814019015692579780041430129235933316031791644979
   6339758350009860700246995193430499911398483897120897639955259087470409875
   3691373830615805779319239570083602972481544925330509176977531530358318061
   441249975602991969588856988898729867579653294934514074112

   Fa of R are 5657657687687868767675566745453434983759382793287598327598375
   9328723756788798798090899878778676756564545453342342334324354657657687687
   98879878687675765644535434287237 
   an
   5668768786876767556674545343498375938279328759832759837593827592872375678
   8709089987877867675656454545334234233432435465765768768798798798798786876
   754535434276993
   #+xample

**** Homework 7
	 DEADLINE: <2018-11-01 Thu> SCHEDULED: <2018-10-29 Mon>
	 :PROPERTIES:
	 :ARCHIVE_TIME: 2018-11-12 Mon 12:14
	 :ARCHIVE_FILE: ~/.emacs.d/Notebooks/BSU.org
	 :ARCHIVE_OLPATH: Fall 2018/Math307/Assignments
	 :ARCHIVE_CATEGORY: BSU
	 :ARCHIVE_TODO: DONE
	 :END:
***** Description
   Foundations of Cryptology
   Assignment 7
   Five	of	the	employees	of	DigiCrime	Inc.	have	decided	to	supplement	their	pensions	by	doing	freelance	
   work	for	one	of	the	competitors,	CyberThievery,	of	DigiCrime.	Each	employee	of	DigiCrime has	a	
   public	RSA	key	for	confidential	communication.	Here	are	the	keys	of	the	five	employees	under	
   consideration:

   | Name           |                                                                       Encryption Modulus | Encryption Exponent |
   |----------------+------------------------------------------------------------------------------------------+---------------------|
   | BiggyBucks     |        138167915492481816745409346812614907970213601388948993432404324912548722779337539 |                   5 |
   | Dumas A Post   |           689234730968542058710415199123628060022111911748855188203650454001478717930441 |                   5 |
   | Penny Pinch    |           165927789907443292785652054606917804467309174081946624778696246358960638705571 |                   5 |
   | Sleezy Nickels | 9707030033411217539906954498964338207893718488045203990403325340285676761140144260245667 |                   5 |
   | Dolly Dimes    | 9702513696679623002778707839853209062395283481756367743103770927153046936810417007760591 |                   5 |

   The	Security	Department	of	DigiCrime Inc.	was	tipped	off	that	some	employees	are	not	as	loyal	to	the	
   company	as	desired,	and	decided	to	monitor	communication.	Their	handler	at	CyberThievery	sent	
   these	five	employees	a	message,	encrypted	for	each.	These	five	encrypted	versions	of	the	message	have	
   been	intercepted	by	the	security	department	of	DigiCrime.	These	are,	in	no	particular	order,

   M1=8680494616758492300153857128626182886244875669712992627620622363379875255673298873890889
   M2=3740176144174317705113182325751346003703203506734421120250951010374481407984708481673873
   M3=1571157443614188818570414758920219335869445581270513124197983268054945711653
   M4=647456570985467791350694143163125775416153692645317710289110387858313344490925
   M5=17089298199140245689054146396696610382482599563869128220501355545433181167922449
   Decrypt	the	message

***** Solution
****** Part 1 - How I solved it
	   							   Justin Johnson
									  113088974
									   Math307

   Before the deadline was changed, I tried to write my own crt() method.
   Doing so wasn't too difficult, but seemed more work than normal for assignments
   given in this class. On Nov 1, 2018 we covered the CRT method in class and 
   showed the sage code in class. From that session I got the following results

   : 179702189046065030137840983877506282733808216772222487872385030013418159775151368010537808270369776111280249922696184622250812210618422156974500421843302635815511055022781078203555271102862470424542573876078160729973527171345068730365265430297970391004390643094550260335823552446001
   : 'Next hack DigiCrime'

   To get to that point, I reviewed "Common Encryption Exponent Attack". I saw
   that this 'company' had written the SAME message to DIFFERENT employees using
   the same encryption exponent. Because of this case, we can invoke the CRT 
   (Chinese Remainder Theorem) to discover the original message.

   There  are a few things that are important to remember:

   E_1=M^e mod n_1	(Alice)
   E_2=M^e mod n_2	(Bob)

   Using CRT we can solve 
	   E_1=M^e mod n_1	
	   E_2=M^e mod n_2	
	for M.
 
	M is the unique solution of 
	   E_1=M^e mod n_1	
	   E_2=M^e mod n_2	
	modulo n1*n2
 	   M mod n1*n2 = M because M <n1,n2

	   *CHINESE REMAINDER THEOREM (CRT)*
	   let n1, n2, ... , nk be natural numbers such that for i,j distinct incices one
	   has gcd(ni,nj)=1

	   then the system of linear congruences has a solution which is unique modulo:
		   N=n1*n2*..*nk
		
       Solution: x=b1*N1*x1 + b2*N2*x2+...+bk*Nk*xk mod N
       where Ni=N/ni and xi=(1/Ni) mod ni

   I had implemented the above separately, but in class we were introduced to 
   the sage method 'crt()' which is a cleaner implementation. My method than follows

   crt(list_of_ciphertext, list_of_modulii) calculates x=b1*n1*x1 + ... + bk*nk*xk
   this gives us some number, and the eth_root of that number should give us the 
   message, according to my notes above. The issue was the encrypted messages need
   to one-to-one correlate with their modulii, and that correlation was unkown.

   We were reminded that the modulus is akin to a box, and the encryption akin to
   a message (which it is). The message cannot be bigger than the box. using that idea
   I was able to properly sort the messages in proper order. After some guess and check
   I came up with:
   : 179702189046065030137840983877506282733808216772222487872385030013418159775151368010537808270369776111280249922696184622250812210618422156974500421843302635815511055022781078203555271102862470424542573876078160729973527171345068730365265430297970391004390643094550260335823552446001
   : 'Next hack DigiCrime'

****** Part 2 - Sage Code
   #+NAME: Homework 7 (Common Encryption Exponent)
   #+HEADER: :tangle ./src/sage/commonEncryptionExponentHmwk7.sage
   #+BEGIN_SRC sage
   #################################################################################################
   # The input is a number and the output is the original message. If the input is not padded ASCII#
   # version of a message it returns the value: "This is not a padded ASCII string"                #
   #################################################################################################
   def ASCIIDepad(Number):
       ndigits=len(str(Number))
       n = ndigits % 3
       if (n > 0):
           print("This is not a padded ASCII string\n")
       else:
           L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)]
           N = ""
           for i in range(Number.ndigits()/3):
               N = chr(L[i]) + N
           return(N)

   b=[
   17089298199140245689054146396696610382482599563869128220501355545433181167922449,
   647456570985467791350694143163125775416153692645317710289110387858313344490925,
   1571157443614188818570414758920219335869445581270513124197983268054945711653,
   8680494616758492300153857128626182886244875669712992627620622363379875255673298873890889, 
   3740176144174317705113182325751346003703203506734421120250951010374481407984708481673873
   ]
   # encryption canNOT be larger than the modulus
   n=[
   138167915492481816745409346812614907970213601388948993432404324912548722779337539,
   689234730968542058710415199123628060022111911748855188203650454001478717930441,
   165927789907443292785652054606917804467309174081946624778696246358960638705571,
   9707030033411217539906954498964338207893718488045203990403325340285676761140144260245667,
   9702513696679623002778707839853209062395283481756367743103770927153046936810417007760591
   ]

   e=5
   x = crt(b,n); x
   M=x.nth_root(e)
   M=ASCIIDepad(M); M
   #+END_SRC

   #+RESULTS: Homework 7 (Common Encryption Exponent)
   : 179702189046065030137840983877506282733808216772222487872385030013418159775151368010537808270369776111280249922696184622250812210618422156974500421843302635815511055022781078203555271102862470424542573876078160729973527171345068730365265430297970391004390643094550260335823552446001
   : 'Next hack DigiCrime'

**** Homework 9
#+NAME: El Gamal Security
#+HEADER: :tangle ./src/sage/hmwk9.sage
#+BEGIN_SRC sage

###########################
# RSA & EL GAMAL Functions#
###########################
def ASCIIPad(Message):
	K = (map(ord,reversed(Message)));    
	le= len(K);
	x = [100+K[i] for i in range(le)];
	x = ZZ(x,1000);
	return(x);
	
def ASCIIDepad(Number):
	n = Number.ndigits() % 3;
	if (n > 0):
		print("This is not a padded ASCII string\n");
	else:
		L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
		N = "";
		for i in range(Number.ndigits()/3):
			N = chr(L[i]) + N;
		return(N)
		
def rsaencrypt(Message, encrexp, encrmod):
	A = ASCIIPad(Message);
	E = power_mod(A,encrexp,encrmod);
	return(E);

def rsadecrypt(encr,decrexp,encrmod):
	D = power_mod(encr,decrexp,encrmod);
	N = ASCIIDepad(D);
	return(N);

# key is: (p,g,b)
# M in this case is the ciphertext E
def egVerify(key, M, y, s):
	v1=(power_mod(y,s,key[0]) * power_mod(key[2],y,key[0])) % key[0]
	v2=power_mod(key[1],M,key[0])
	return v1==v2
	
def egSign(key, M, x):
	r = randint(1,key[0])
	while gcd(r,key[0]-1) != 1:
		r+=1
	#print("gcd(r:{},(p-1):{})={}".format(r,key[0]-1,gcd(r,key[0]-1)))
	y = power_mod(key[1],r,key[0])
	s = ((M-(x*y))/r) % (key[0]-1)
	return (y,s)
	
def isqrt(n):
    return int(floor(sqrt(n)))

def usqrt (n):
    ur = isqrt(n)
    if ur ** 2 < n:
        ur = ur + 1
    return(ur)

def FermatAttack (n, rounds):
	st = usqrt(n)
	for x in range(st, st + rounds + 1):
		#print (x-st)
		sq = x ** 2 - n
		y = isqrt(sq)
		if y ** 2 == sq: 
			print "Factor found in round {0}".format(x-st+1)
			return(x + y)
	print "No factor found in {0} rounds".format(rounds)
	return 0
###########################

# IMPORTANT!!
# RSA is used to encrypt the below messages, El Gamal to sign them
# Alice and Bob  are secretly sharing Alice's private El-Gamal key to maintain a covert channel of communication

##############################################
# Information given in assignment description#
##############################################
# RSA KEYS
# Alice's Key
rsa_akey={'n':11739085287969531650666764880307069646178466406116413,'e':29}
# Bob's key
rsa_bkey={'n':46956341151878126602666849327932976850293104473816077, 'e':71}
# Jack's key
rsa_jkey={'n':105651767591725784856000289747489691397274520258086741,'e':113}
# Lucy's key
rsa_lkey={'n':187825364607512506410666935319870481320981631530945317, 'e':173}
rsa_keys=[rsa_akey,rsa_bkey,rsa_jkey,rsa_lkey]

# El Gamal Keys
# Alice's Key
eg_akey={'p':11739085287969531650666764880307069646178466406133747, 'g':122 ,'b':4559251933765135908042850372269050947311088678478407}
# Bob's Key
eg_bkey={'p':46956341151878126602666849327932976850293104473818163, 'g':14646,'b':41773094887790182197984303656431777160492104718067730}
# Jack's Key
eg_jkey={'p':105651767591725784856000289747489691397274520258105207,'g':1771562,'b':77714098443250567285634413412177559464041605041509476}
# Lucy's key
eg_lkey={'p':187825364607512506410666935319870481320981631530959327,'g':214358883,'b':14644041014569643811484259591673998237151900979559891}
eg_keys=[eg_akey,eg_bkey,eg_jkey,eg_lkey]

# Alice's private El Gamal Key (x) - shared with bob for covert channel
eg_apkey=7699542093548349244049573757501851670562589091966419

# REVIEW EL GAMAL
# Public Key: (p,b,g) where p is a prime number, b=g^x mod p, g is a primitive root 1 < g < p of p
# Private Key: (x) x is a random number

# RSA Encrypted Message E | y=g^r mod p | s=(M-x*y)/r mod (p-1)
unknown1={'E':115251811749469530248002415406523254651489743459017725,'y':19240616197970611747502124859803652312085074442112010,'s':32706719515423467589632843847126484468195520962513517}
unknown2={'E':19659961695727243828141973694524447795978653272532149, 'y':50397128494149821593269937078000120329058172709578908,'s':47844269820223698406809962518912128051231159162499240}
unknown4={'E':126624117419296887665831621310305588878545225870594430,'y':9352666161952933766287125798193970300698629396417740,'s':4002797869345137661356168947662543489885815101905269}
unknown3={'E':1199064630279469528093193372862416429357320708704542,'y':105216848703587739343303886089914553038944537874501648,'s':139693573510952382531551260015801085872053556486585886}
unknowns=[unknown1,unknown2, unknown3, unknown4]

# Alice's message search
#print("Alice's Message Search Results")
rsa=(rsa_akey['n'],rsa_akey['e'])
eg=(eg_akey['p'],eg_akey['g'],eg_akey['b'])
x=eg_apkey

# El Gamal Signature Verification
M=ASCIIPad("Done!")
S=egVerify(eg,M,unknown4['y'],unknown4['s'])

# Fermat Attack Attempt
n=rsa[0]
e=rsa[1]
p=FermatAttack(n,10)
q=n/p
phi=(p-1)*(q-1)
d=inverse_mod(e, phi)

# Bob's message search
#print("Bob's Message Search Results")
rsa=(rsa_bkey['n'],rsa_bkey['e'])
eg=(eg_bkey['p'],eg_bkey['g'],eg_bkey['b'])

# Fermat Attack Attempt
n=rsa[0]
e=rsa[1]
p=FermatAttack(n,10)
q=n/p
phi=(p-1)*(q-1)
d=inverse_mod(e, phi)
bt=d
bn=n
M=rsadecrypt(unknown2['E'], d, n)
M=rsadecrypt(unknown3['E'], d, n)

# El Gamal Signature Verification
M=ASCIIPad("Buy IBM")
S=egVerify(eg,M,unknown1['y'],unknown1['s'])

# Jack's message search
#print("Jack's Message Search Results")
rsa=(rsa_jkey['n'],rsa_jkey['e'])
eg=(eg_jkey['p'],eg_jkey['g'],eg_jkey['b'])

# El Gamal Signature Verification
M=ASCIIPad("Sell AT&T")
S=egVerify(eg,M,unknown2['y'],unknown2['s'])

# Lucy's message search
#print("Lucy's Message Search Results")
rsa=(rsa_lkey['n'],rsa_lkey['e'])
eg=(eg_lkey['p'],eg_lkey['g'],eg_lkey['b'])

# El Gamal Signature Verification
M=ASCIIPad("Sell all")
S=egVerify(eg,M,unknown3['y'],unknown3['s'])

# Fermat Attack Attempt
n=rsa[0]
e=rsa[1]
p=FermatAttack(n,10)
q=n/p
phi=(p-1)*(q-1)
d=inverse_mod(e, phi)
M=rsadecrypt(unknown1['E'], d, n)
M=rsadecrypt(unknown4['E'], d, n)
############################################

# 1) Determine each Message
# 2) Determine For whom each message was intended
# 3) Determine from whom each message is, by verifying the corresponding El Gamal Signatures
oneThruThree="""
| Message     | To Whom                        | From Whom               |
|-------------+--------------------------------+-------------------------|
| Fermat      | Decrypted using private key of | verifying El Gamal Sigs |
|-------------+--------------------------------+-------------------------|
| "Buy IBM"   | Lucy                           | Bob                     |
| "Sell AT&T" | Bob                            | Jack                    |
| "Sell all"  | Bob                            | Lucy                    |
| "Done!"     | Lucy                           | Alice                   |
"""
# 4) Determine any messages Alice passed covertly to Bob through her El Gamal Signature
#M2=unknown1['E']
M2=ASCIIPad("Done!")
y=unknown4['y']
s=unknown4['s']
p=eg_akey['p']-1
D=((M2-(x*y))/s) % p
#D=rsadecrypt(D, bt, bn); D
D=ASCIIDepad(D); D
#+END_SRC

#+RESULTS: El Gamal Security
: Factor found in round 1
: Factor found in round 1
: Factor found in round 1
: 'Downsizing'

**** Homework 10
	 
#+BEGIN_EXAMPLE 
Part1 Prep

- Looked for common y to see if I could dicern the random number 'r', no common y's were found
- Used Initial Segment attack to find (p-1) of Alice's public EG key
- Attempted Fermat Attack for Lucy's public RSA key - Failed
- Attempted One Line factoring method to discover public RSA key - Success!
#+END_EXAMPLE

*USEFUL LINKS FOR REFERENCE*
[[https://blackboard.boisestate.edu/bbcswebdav/pid-5733616-dt-content-rid-30155838_1/courses/1189-70632MATH307001/CommonRendom%20Number.PDF][El Gamal Sig and Random Number Schema]]
[[https://blackboard.boisestate.edu/bbcswebdav/pid-5733616-dt-content-rid-30155832_1/courses/1189-70632MATH307001/Legendre%20Covert%20Channel.pdf][Legendre type covert Channel]]
[[https://share.cocalc.com/share/5350c8ff-68cc-42b4-921d-a5cbf8ba1ff2/Sage%20Files/ISAttack.sagews?viewer=share][IS attack code]]
[[https://share.cocalc.com/share/ace6d4f1-2ecc-4078-bce1-11b9bb02a0ac/LegendreCovertChannel.sagews?viewer=share][Legendre Code]]
[[https://share.cocalc.com/share/5350c8ff-68cc-42b4-921d-a5cbf8ba1ff2/Sage%20Files/Fermat%20Attack.sagews?viewer=share][Fermat Attack Code]]
[[https://share.cocalc.com/share/5350c8ff-68cc-42b4-921d-a5cbf8ba1ff2/Sage%20Files/RSA%20Encryption.sagews?viewer=share][RSA Encrypt code]]
[[https://share.cocalc.com/share/5350c8ff-68cc-42b4-921d-a5cbf8ba1ff2/Sage%20Files/RSA%20Decryption%20.sagews?viewer=share][RSA Decrypt code]]
#+NAME: Homework 10 Solutions (Legendre Function)
#+HEADER: :tangle ./src/sage/hmwk10/legendre.sage
#+BEGIN_SRC sage
######################
#Function definitions#
######################
def ASCIIDepad(Number):
    n = Number.ndigits() % 3;
    if (n > 0):
        print("This is not a padded ASCII string\n");
    else:
        L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
        N = "";
        for i in range(Number.ndigits()/3):
            N = chr(L[i]) + N;
    return(N);

def ASCIIPad(Message):
    K = (map(ord,reversed(Message)));
    le= len(K);
    x = [100+K[i] for i in range(le)];
    x = ZZ(x,1000);
    return(x);

def rsadecrypt(encr,decrexp,encrmod):
    D = power_mod(encr,decrexp,encrmod);
    N = ASCIIDepad(D);
    return(N);

def rsaencrypt(Message, encrexp, encrmod):
    A = ASCIIPad(Message);
    E = power_mod(A,encrexp,encrmod);
    return(E);

def ISAttack (R):
    n = R.ndigits()
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"
	
def NewLegendre(a,p):
    if is_prime(p):
        return (1+kronecker(a,p))/2
    else:
        print "2nd argument has to be a prime"
        
def BlockNumber(y,primelist):
    m=0
    for i in xrange(0,4):
        m = 2*m + NewLegendre(y,primelist[i+10])
    return m+1

def BlockContents(y,primelist):
    k=0
    for i in xrange(0,10):
        k=10*k+NewLegendre(y,primelist[i])
    return k

def KeyDiscover(ylist,primelist):
    c=10^10
    k=0
    for i in xrange(16):
        d=16-BlockNumber(ylist[i],primelist)
        k=k+(BlockContents(ylist[i],primelist))*(c^d)
    return int(str(k),2)
	
def isquare (n):
    if isqrt(n) ** 2 == n:
        return(True)
    return(False)

def isqrt(n):
    return int(floor(sqrt(n)))

def usqrt (n):
    ur = isqrt(n)
    if ur ** 2 < n:
        ur = ur + 1
    return(ur)

def OneLine (n, iter):
    for x in range(1, iter + 1):
        sq = usqrt(x * n)
        y = sq ** 2 % n
        if isquare(y) == True:
            t = isqrt(y)
            u = gcd(n, sq - t)
            print("Factor found in round {0} rounds".format(x))
            return(u)
    print("No factors found")

# key is: (p,g,b)
# M in this case is the ciphertext E
def egVerify(key, M, y, s):
    v1=(power_mod(y,s,key[0]) * power_mod(key[2],y,key[0])) % key[0]
    v2=power_mod(key[1],M,key[0])
    return v1==v2
	
def egSign(key, M, x):
    r = randint(1,key[0])
    while gcd(r,key[0]-1) != 1:
        r+=1
	#print("gcd(r:{},(p-1):{})={}".format(r,key[0]-1,gcd(r,key[0]-1)))
    y = power_mod(key[1],r,key[0])
    s = ((M-(x*y))/r) % (key[0]-1)
    return (y,s)
	
#Finds random number used in El Gamal signature
# Remember
# r=(M2-x*y)/s mod (p-1) **gcd(s,p-1) must equal 1**
def rDiscover(M,x,y,s,p):
	if gcd(s,p-1) == 1:
		return ((M-x*y)/s) % (p-1)
	print("Value for 'r' Could not be found")
	return 0
######################

description="""
Foundations of Cryptology
Assignment 10
The OTB (Office of Technology Busting) made special purpose computer chips for generating
El-Gamal signatures and covertly planted in each chip *14 prime numbers* to leak the *160-bit private
key of the signer*, *10 bits per signature*. The *last four prime numbers* are used to code which of the
sixteen blocks of 10 bits each is being leaked by the particular signature, and primes 1 through ten
leak these ten bits prime 1 leaks bit 1, prime 2 leaks bit 2, and so on.
Alice bought one of these chips and installed it in her computer. Here are the 14 covert prime
numbers planted in her chip:"""

primelist=	[2610874309742867231360502542308382199053675592825240788613991898567287,
		6881793749340807728335795394301261629479870548736450984003401594706373,
		8314906195914825136973281314862289454100745237769034410057080703111511,
		5127114594552921209928891515242515620324828055912854227507525717981667,
		7473570262981491527797413449568788992987500442157627511097882499376811,
		9062890227065912603127119521589474574157513825150650905007553408748219,
		2815984929359632269852681585809504709739738485231104248045693804710167,
		8302655538010818866476054310788175542136407374106205605523687223947057,
		5812242019121022573901665288968349097396414947780422731613987785640429,
		4198272844134050365811754869582636140810856859347877704841433599229643,
		8724880795485531802023255050614524952922474293642065329619154912668053,
		6069438450681407641506962917791070874166946435905950292905549552889463,
		4125842236067060541266621757734462223575905687273574099511410424381497,
		9501247275887974857856234450269247606386273485070460241146322057229349]

description="""
Alice regularly corresponds with Lucy using the following protocol. They encrypt messages for
each other using the RSA crypto-system, and sign these messages using the El-Gamal system.
Lucy's RSA public key is as follows:"""
rsa_lkey={'n':1380329510951197510100010724038844435804781490991185453524669, 'e':431452543435309613375031056399003408107128387827408402715967, 't':0}
n=rsa_lkey['n']
e=rsa_lkey['e']
p=OneLine(n,10) # Private RSA key
q=n/p
phi=(p-1)*(q-1)
t=inverse_mod(e,phi)
rsa_lkey['t']=t; t

#Alice's El-Gamal signature key is as follows:
eg_akey={'p':10000000000000000000000000000000000000000000000000000000000000000005707, 'g':2, 'b':5829711445814756593150837441577049879646826835967016234521362166032923}
#p-1 == p
n=eg_akey['p']-1
p=ISAttack(n)
q=n/p

description="""
Here are sixteen messages from Alice to Lucy which have been collected by the Cyber Forensics
unit of the OTB: (E is the RSA - encrypted message, and y and s have their usual meanings in the
context of El-Gamal signatures: s is the result of signing the padded ASCII version of the message.)
"""

M1={'E':1134781463560674835061224378575070131233310977090840813092301,'y':6355654156581339292380028178295946379397857230419335473049773634105011, 's':9165085756767321557707624388546095482608475475072419124793930216287642}
M2={'E':348526314010735292619330553642899978920623570033772324649849,'y':6157738735079726271974947267390448530039834693941568486254984166399169, 's':7580596732923277682277308429550458486421120322969733810425808677713063}
M3={'E':144280751261655647389997303952062412262367552233518955034975,'y':9335313663168312334842734241780762294755281133475486862667663109265693, 's':902452660748342094448043076348013766357745134358961491151947971831298}
M4={'E':448648149210542717563843830926466689272194100737881817695849,'y':5666312454503499142803478855324287143700047631332918051757975784387852, 's':2339212545643638702289301089883628788751421175252652804149103380819500}
M5={'E':414463904058626538164714974954260575549577988440230717028375,'y':8609729555305475123927447895155480568383891784974360653476349663970219, 's':7542295030958909202194788901128163331877935875245454365944680358801016}
M6={'E':762798455103578108350927164584389075158784895748140579440858,'y':7365404439138911411864937298776875814102498525963049435105763372378772, 's':1606771469519514190569490683909892293358374332166482060564995247015982}
M7={'E':1176909860227801331876617938268884763814085436948672573185440,'y':5705440343386587753765002035968279773205391692599442025007820809081663, 's':795056909654530610475130199155990661441694481486389575943239181360163}
M8={'E':1038784868243291703163122137403638880051390504859030077046832,'y':9139181219517140532824520580591540432442737355121485514849816985670182, 's':718431597798222122752848311170876804983108930346831880471325577707750}
M9={'E':534307298423793561315454335890652994099216705910796252757003,'y':3851953190357247351746340095276683473382065321260493360272121028908078, 's':4425969620597187781028255597865205402426141520827972218693653450885014}
M10={'E':294792873244090595225360406826078427911073375481311873865117,'y':8332119728236605996252741802820164399490394892793656670206410123540806, 's':5683798202666903152470108694640039089754745733985049884601886790614149}
M11={'E':1355904422553023580096618287264066452910577884654954174043845,'y':1090916439028367923335435833686239225083325662650219511577614470087626, 's':3486112167704760872711104718953680515027994408104257306046727398596982}
M12={'E':528414128418567725915368190435344574500994961365177769853400,'y':4044337428348522271547535017777415980322724356426081427629324943634693, 's':1280391621642407995368091574204252749818718773673779092796712310184877}
M13={'E':382048408707112057090584331184203176355530469092303817253852,'y':5047503978916103346914776520107614498353295441864520623517103573476005, 's':6622497751951716014580838234980317172956294365936998965231635552650598}
M14={'E':1138109602667405943072422513690232405305131283131822608386662,'y':3079609686866100016134750688150613028636970390199280613932162055042282, 's':7651064433223341671855042720940102025407140854125385153059255930291852}
M15={'E':648551792358033195908225921930717188912777934403051076101283,'y':2507949926452818146783101167935559217583543852145717090862513023080430, 's':1876892947883839710552556001755856886960301874237874824837728826983258}
M16={'E':1108329618226979748565921595052080391831955721135843401833413,'y':1137237284834714268920432440084126521105380025168123492652543171722168, 's':4974270349376072715089518021560121124590346430908794289954437585093573}
M=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16]
y=[i['y'] for i in M]
s=[i['s'] for i in M]
E=[i['E'] for i in M]
p=primelist


#The following replicates info from Blackboard:Software:Legendre-CoCalc
#This discovers 'x'? - verify somehow
x=KeyDiscover(y,p); x # Takes about 20s to compute
#1290003348882681184907543014445365590610205625395L

#Example Usage of Block leakage
#BlockNumber(y[0],p) #Quick computation
#BlockContents(y[0],p)
#for i in range(16):
#	bc = BlockContents(y[i], p)
#	print (BlockNumber(y[i],p), bc)
	
# Decrypt messages sent to Lucy using Lucy's private key:
#for i in M:
#	mi=rsadecrypt(i['E'],rsa_lkey['t'], rsa_lkey['n']); mi

# Remember r = (M-x*y)/s mod (p-1); use rDiscover(M,x,y,s,p), to find each random number

#From this information determine:
#1. Lucy's private RSA key;
	#361305388410523
#2. Alice's private El-Gamal key;
	#x=1290003348882681184907543014445365590610205625395L
#3. All the messages from Alice to Lucy;
mes=[
	'Trust the OTB!',
	'I trust them.',
	'They make chips',
	'for signatures.',
	'Did you get it?',
	'I may visit.',
	'Perhaps not.',
	'Stay cool.',
	'Say nothing.',
	'Good move!',
	'Change keys.',
	'Bob cracked it',
	'Maybe also Jack',
	'Mine are safe.',
	'Uh-oh...',
	'They are not?']
#4. All the random numbers used by Alice during signature generation.
#rDiscover(M,x,y,s,p):
r=[]
for i in range(len(mes)):
	r.append(rDiscover(ASCIIPad(mes[i]), x, y[i],s[i], eg_akey['p']))
	print(str(i+1) + ". " + str(r[i]))
randomNumbers="""
1. 0
2. 279609980683956300275566144892650827765370570419
Value for 'r' Could not be found
3. 0
Value for 'r' Could not be found
4. 0
Value for 'r' Could not be found
5. 0
Value for 'r' Could not be found
6. 0
7. 561632179750555610745205884336981428558537921825
Value for 'r' Could not be found
8. 0
Value for 'r' Could not be found
9. 0
10. 660302497351884884272183075684764705268237246717
Value for 'r' Could not be found
11. 0
12. 424540208662980822891917406935720503852329046165
Value for 'r' Could not be found
13. 0
Value for 'r' Could not be found
14. 0
Value for 'r' Could not be found
15. 0
16. 1304740743478692639491729486909033636608504466639
"""
s=((ASCIIPad(mes[1])-x*y[1])/r[1]) % (eg_akey['p']-1); s #This is the correct 'r'
#+END_SRC

#+RESULTS: Homework 10 Solutions (Legendre Function)
#+begin_example
Factor found in round 3 rounds
361305388410523
1290003348882681184907543014445365590610205625395L
Value for 'r' Could not be found
1. 0
2. 279609980683956300275566144892650827765370570419
Value for 'r' Could not be found
3. 0
Value for 'r' Could not be found
4. 0
Value for 'r' Could not be found
5. 0
Value for 'r' Could not be found
6. 0
7. 561632179750555610745205884336981428558537921825
Value for 'r' Could not be found
8. 0
Value for 'r' Could not be found
9. 0
10. 660302497351884884272183075684764705268237246717
Value for 'r' Could not be found
11. 0
12. 424540208662980822891917406935720503852329046165
Value for 'r' Could not be found
13. 0
Value for 'r' Could not be found
14. 0
Value for 'r' Could not be found
15. 0
16. 1304740743478692639491729486909033636608504466639
7580596732923277682277308429550458486421120322969733810425808677713063
#+end_example

** CS253
*** Lecture
**** Structs
***** Notes
****** introduction

 A struct is a /class/ without any /methods/ (it only has /attributes/)

 There is more to structs than the above statement, we'll investigate this more.
****** Java comparison

 *KEY SIMILIARITIES*
  - A ~struct~ is a user-definied datatype (primitive c type
  - others...

 *KEY DIFFERENCES*
  - Syntax syntax syntax!
  - A ~struct~ has no methods
  - A ~struct~ has no constructors
  - A ~struct~ cannot inherit members from another ~struct~
  - Memory Management is different

****** Accessing Member Variables in a Struct

| Using a struct variable | Using a pointer vairable |
|-------------------------+--------------------------|
| purple.r = 255;         | pColor->r = 255;         |
| purple.g = 0;           | pColor->g = 0;           |
| purple.b = 255;         | pColor->b = 255;         |

****** Defining struct variables

#+BEGIN_SRC C
struct Color {
	unsigned char r;	//Red 0...255
	unsigned char g;	//Green 0...255
	unsigned char b;	//Blue 0...255
} purple, pink;			//Variables!!!
#+END_SRC
The above example defines a new data type, Color, and also defines two /uniinitialized/ 
color variables, purple and pink
****** Initializing a struct Variable

#+BEGIN_SRC C
struct Color {
	unsigned char r;	//Red 0...255
	unsigned char g;	//Green 0...255
	unsigned char b;	//Blue 0...255
} purple, pink;			//Variables!!!
struct Color purple = {255,0,255};
#+END_SRC
****** Struct Variable operators
	   - Assignment with "=" operator: purple = pink;
	   - Retrieve its address with "&": pColor = &purple;
	   - Accessing members with "." operator: int r = purple.r;
	   - Comparisons (e.g. "==") are *NOT* supported
****** Structs and Functions
	   - Struct variables (and everything in C) are /pass by value/
	    - ~struct Color chosenColor = selectColor(purple);
	   - Passses a _copy_ of the value of the struct purple to the selectColor func
****** Arrays of Structs
	   
struct Color primaries[8]; //An array of 8 Colors
primaries[0] = purple
***** Examples

 #+BEGIN_SRC C
 struct Place {
  int x;             //X-coodr of this Place
  int y;             //Y-coodr of this Place
  struct Place* next;//Address of next palce
 };
 .
 .
 .

 //Define a function to construct/initialize a new Place
 struct Place* newPlace(int xp, int yp){
     struct Place *p = malloc(sizeof(struct Place));
     //malloc - memory allocation
     p->x = xp;
     p->y = yp
     return p;
 }
 #+END_SRC

**** Malloc and Free
***** Notes

 malloc returns (void *)
 /this/ returns a reference to itself

 C lacks java's garbage collection service. you must explicitly /free/ everything
 you alllocate with /malloc/

 If you don't, you *will* /leak/ memory

***** Examples

 #+BEGIN_SRC C
 //Define a struct Place datatype
 struct Place{...};
 .
 .
 //Build an instance of a Place in memory
 struct Place* p = malloc(sizeof(struct Place));
 .
 .
 //Recycle the memory in the Place referenced by p
 free(p);
 #+END_SRC

**** Typedef
***** Notes
	  Basically just an alias to a datatype
***** Examples
	  ~typedef unsigned char unsbyte;~
	  ~typedef struct Color* pColor;~
	  the above definss unsbyte to be an alias for unsigned char
	  typedef does NOT define a new data type
	  this helps to write more readable code
**** Function Pointers
***** Notes
	  *I accidently deleted stuff...missing notes and files*
#+NAME: Function Pointers
#+HEADER: :dir ./src/c
#+HEADER: :file functionPointers.txt
#+HEADER: :tangle ./src/c/functionPointers.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h>)
printf("Hello World");
#+END_SRC

#+RESULTS: Function Pointers
: DEBUG: Entering a string/function foo!

**** Debugging, valgrind
***** Defining Macros 
	  - A macro is 'preprocessed'. C can expand functionality using these macros
***** Debug macro
#+NAME: Function Pointers
#+HEADER: :main no :dir ./src/c
#+HEADER: :tangle ./src/c/debug.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h>)
//in makefile
//use debug target
/*
	CFLAGS = -Wall -std=c99
	EXE=foo

	all: $(EXE)

	debug: CFLAGS += -DDEBUG -g -Og
	debug: $(EXE)
	
	$(EXE): foo.o
		gcc $^ -o $@
*/

//uncomment if in debug.h
//#ifdef DEBUG
#define DPRINT(s) printf("DEBUG: %s\n", s)
//#else
//#define DPRINT(s)
//#endif

int main(){
	//Example usage
	DPRINT("Entering a string/function foo!");
	//This is expanded into printf("DEBUG: %s\n", "Enetering a string/function foo!")
}
#+END_SRC

***** Valgrind
	  - Toolkit popular for memory issues (leaks, bad pointers)
	  - Valgrind is a virtual machine executing your program
	  - See /CS253 class resources/ for examples
**** I/O
***** Terminology
****** Processes
	   - Process id
	   - user id
	   - address space
		 - text: A segment of memory containing executable code
		 - heap: A segment of memory for data
	   - File Descriptors
****** Thread States
	   - RUNNABLE: awaiting a processor to execute it
	   - EXECUTING: A processor is executing your thread
	   - BLOCKED: Awaiting I/O
****** File Descriptors
	   - Each process has a File Descriptor Table
	   - Each active file descriptor is bound to a file
****** Buffers
	   - Each high-level FILE stream has a buffer in user-space
	   - low-level files are buffered in kernel-space
**** Threads, Processes and Data
***** Stack
	  - Return addresses, parameters, and automatic variables
***** Heap
	  - Allocated memory blocks
***** True vs. Pseudo-Concurrency
	  - Processor is a CPU core, an independent processin gunit
	  - /threads/ truly executing concurrenlty is limited by the number of /processors/
	  - /True concurrency/ Modern computer hardware supports several cores and can execute several threads concurrently
	  - /Pseudo-Concurrency/ An operating system time-shares 1...M processors amongs 1...N threads
***** Processes in Unix-Like Systems
	  - dispaly information about each process with
		- ~ps ax~
	  - count the number of executing processes
		- ~ps ax | wc -l~
	  - PID - process ID
	  - PPID - parent process id
	  - UID - user id
	  - GID - group id
	  - VSZ - vitrual storage size (includes 'swapped' memory)
	  - RSZ - resident storage size ("not swapped memory")
	  - WCHAN - wait channel (the reason a process is waiting)
	  - STAT - process status flags
	  - COMMAND - executing program and arguments if available

****** fflush(stdout); - flushes a stream
***** Threads in java
****** Threads
	   - a /thread/ is a sequence of instructions executed by a /processor/ core
	   - A /single-threaded/ program has one threaed
	   - many real-world programs are multi-threaded
	   - In order to run multi threaded in my own program, I must request a thread.
#+NAME: Java Single Threaded Example
#+BEGIN_SRC java
while(serverIsRunning){
	request=queue.receiveNextRequest();
	response=request.doWork();
	response.send();
	queue.remove(request);
}
#+END_SRC

#+NAME: Threading in Java
#+BEGIN_SRC java
class ServerThread extends Thread{
	.
	.
	void run(){
		while(serverIsRunning){
			request=queue.recieveNextRequest();
			response=request.doWork();
			response.send();
			queue.remove(request);
		}
	}
	
	ServerThread thread1, thread2;
	public static void main(String args){
		.
		.
		thread1 = new ServerThread(...);
		thread2 = new ServerThread(...);
		thread1.start(); //JRE will invoke thread1's run()
		thread2.start(); //JRE will invoke thread2's run()
	}
}
#+END_SRC
		- Race Condition
		  - a /race condition/ arises when
			- Two or mor threads access shared data
			- And result depends upon the order in which the threads execute their machine instructions
		- Critical Section
		  - A sequence of machine instructions manipulating shared data
		  - Results are non-deterministic
		  - *Mutual Exclusion* - permit no more than one thread at a time (synchronized)
			- Blockd thread - not currenlty executing
			- Unblocked thread
			  - another thread specifically unblocks it
			  - A hardware event (interrupt) unblocks it
***** Threads in C
	  - POSIX Threads
	  - Each process has one thread
	  - THat thread starts in /main/
	  - Memory in other processes is normally inaccessible
*** In-Class Exercises
#+NAME: Fork and Wait
#+HEADER: :exports results
#+HEADER: :main no
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <unistd.h> <sys/types.h> <sys/wait.h>)
void newFork(){
	//Create a duplicate process
	int pid = fork(); //Fork will return twice
	//Fork 'creats' a thread to run child and parent concurrently
	//This code block after the fork() call is executed twice!
	if (pid==0){
		for(int i=0; i<1000; ++i){
			printf("I am Luke Skywalker!\n");
		}
		exit(0);//ends current process
	} else if(pid>0){
		int exitStatus;
		for(int i=0; i<1000; ++i){
			printf("I am Darth Vader\n");
		}	
		wait(&exitStatus);//saves child exitStatus into named var. Waits til 
		//child exits before continues
		exit(0);
	}
	perror("There is a disturbance in the force.");
	exit(-1);
}

int main(){
	newFork();
	return 0;
}
#+END_SRC
#+RESULTS: Fork and Wait
[[file:src/c/forkAndWait.txt]]

#+NAME: Example1 Threading
#+HEADER :results output
#+HEADER: :main no
#+HEADER: :tangle ./src/c/ex1.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <pthread.h> <sys/time.h>)
//I want to take advantage of GNU features
#define _GNU_SOURCE

//Define functions implemented below
void *theThread(void *);
void printStuff(char *, int);
void cpuSmoke(int);

int main(void) {

  //Automatic variables (these are private the the thread invoking main)
  pthread_t posixThreadId;
  int result;
  int threadExitStatus;
  void *pThreadExitStatus = &threadExitStatus;

  //Create and start the new thread with default (NULL) attributes
  result = pthread_create(&posixThreadId, NULL, theThread, NULL);
  if (result!=0) printf("pthread_create failed, error=%d\n",result);

  //Print some stuff to stdout
  printStuff("main", 1000);

  //Wait for the child thread to exit
  result = pthread_join(posixThreadId,pThreadExitStatus);
  if (result!=0) printf("pthread_join failed, error=%d\n",result);
  printf("threadExitStatus=%d\n",threadExitStatus);

  //Finished
  return 0;
}

void *theThread(void *arg) {

  //Print a bunch of stuff to stdout
  printStuff("thread",1000);

  pthread_exit((void *) 0);
}

void printStuff(char *id, int count) {
  int i;              //This is an automatic variable on the thread's private stack
  for(i=1;i<=count;i++) {
    printf("%s i=%d\n",id,i);
    //printf("%s ",id);  fflush(stdout);  cpuSmoke(100);  printf("i=%d\n",i);
    fflush(stdout);   //Force the buffer to be written
    //pthread_yield();  //Manually yield the CPU core
    cpuSmoke(1000);
  }
}

void cpuSmoke(int uSec) {
  struct timeval t1;     //Starting time
  struct timeval t2;     //Current time
  long long now;

  //Get the start time in uSeconds
  gettimeofday(&t1,NULL);  //What time are we starting
  unsigned long long start= t1.tv_sec*1000000L + t1.tv_usec;  //Microseconds since epoch

  //Loop stalls the CPU core until uSec have elapsed
  do {
    gettimeofday(&t2,NULL);  //Current time
    now = t2.tv_sec*1000000L + t2.tv_usec;
  } while (now < start+uSec);
}
#+END_SRC

#+RESULTS:

#+NAME: Threads
#+HEADER :results output
#+HEADER: :main no
#+HEADER: :tangle ./src/c/threadsInClass.c
#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <pthread.h> <sys/time.h>)
#define _GNU_SOURCE
long counter = 0;
int n = 20;

void *increment(void *arg){
	for(int i = 0; i < n; ++i){
		++counter;
	}
	pthread_exit((void *) 0);
}

void decrement(){
	for(int i = 0; i < n; ++i){
		--counter;
	}
}

int main(void){
	pthread_t posixThreadId;
	int result;
	int threadExitStatus;
	void *pThreadExitStatus = &threadExitStatus;
	
	decrement();

	result = pthread_create(&posixThreadId, NULL, increment, NULL);
	if (result != 0) printf("pthread_create failed, error=%d\n", result);
	result = pthread_join(posixThreadId,pThreadExitStatus);
	if (result != 0) printf("Pthread_join failed, error=%d\n", result);
	
	printf("Counter: %ld\n", counter);

	return 0;
}
#+END_SRC

#+RESULTS:

*** Assignments
** CS230
*** Assignments
*** Lecture
**** Intellectual Property
***** Closed Source
****** Software Licenses
******* Proprietary LIcense (E.g. Microsoft
		- Manufactuer reserves all rights /not expressly granted/
***** Open Source
****** Notes
	 - Is open source software free?
	 - This isn't necessarily the case
	 - what do you pay for in buying /free/ software?
		 - Technical support
		 - Testing
		 - proprietary aps enhancing the distro
****** Software Licenses
******* Permissive License(s) (E.g. MIT)
  A /permissive license/ imposes minimal restrictions on the 
  distribution of the software

  - Berkeley Systems Division (BSD) License
  - Apache LIcense
  - MIT License
  
  Permits the software to be incorporated into proprietary products
******* Protective ("copy-left license)
  - A /copyleft license/ offers the author of a /derivative work/
	- The right to use the licensed software
	  - So long as the /derivative work/ is also distributed with the /copyleft license/
  - Copyleft software cannot be incorporated into a proprietary product (or even a permissive open source product)
  - Copyleft software can be incorporated into another copyleft product
  - GNU general Public License is an example of this

***** Public Domain
***** Software Patents
****** Patent laws
	   - vary country to country
	   - We will focus on US software patents
	   - Obtaining a US patent does *NOT* guerentee protection globally
	   - Treaties (eg World Trade Organization's Agreement) have tried to change this
		 
****** What does a Patent do?
	   - provides certain rights to a patent holder
	   - In exchange for the complete disclosure of the invention
	   - No one may build, use, sell or import/export without patent holder permis.
	   - Term limited (20 years has been typical)
****** Patent Requirements
	   - Processes, machines, articles of manufacture and compositions of matter
		 - Exceptions (CANNOT be patented)
		   - Abstract ideas
		   - laws of nature
		   - natural phenomenon
	   - Novel - unique, can't be easily determined
	   - Useful
	   - Non-Obvious
****** Copyright vs. Patent
	   - A computer program is an expression of a method, an implementation, and can be copyrighted
	   - A patent protects a program's underlying methodolgy, not the implmenatation.
	   - But...
		 - US supreme court ruled that a numerical algorithm (abstract idea) cannot be patented
	   - Patents protect methodolgy, not an algorithm
	   - The supreme cour ruling itself still has some exceptions
	   - [[https://www.bitlaw.com][bitlaw - software law resource]]
****** Software Patent Take-Aways
	   - Patents are expensive and time-consuming
	   - Patents may not be the best way to protect your software
	   - Preferred methods include:
		 - Trade Secrets
		 - Copyrights
		 - Public Domain (may block others from patenting it!!!)
	   - Patents look cool on your resume
***** Trademarks
****** What is a trademark?
	  - Sign, symbol or logo
	  - Word, Phrase or name
	  - Design or an image
	  - (r)
****** About Tradmarks
	   - Another form of intellectual property
	   - are 'recognizable" like a signature
	   - protects brand names, logos, etc
	   - [[https://www.uspto.gov/trademark][Register a trademark]]
****** Symbols for trademarks
	   - (r) is for registered tradmarks
	   - ^TM is for unregistered trademarks
****** Trademarks for Developers
	   - Even open-source projects may have trademarks!
	   - We encounter trademarks when we implement user interfaces displaying our company's trademark
	   - Most company's have policies rgulating the use and protection of tehir trademark
**** Privacy
***** Notes
	 - Aspects of privacy (as per CS23)
	   - Confidentiality
	   - Integrity
	   - Right to be let alone
	 - privacy expectations vary amongst cultures

***** Definitions
	  - Authentication
		- Protection of confidential information requires us to:
		  - Identify who wnats to access the data
		  - Identify who owns the data
		- /Authentication/ associates an /identity/ with a subject activity
		- Factors
		  - Enables a system to identify users
		  - Multi-factor authentication
	  - Authorization
		- determines what rights a subject has to a datum
		  - ex: triplejay2013 is authorize to read but not write file, foo.txt
	  - Confidentiality Policy
		+ defines who is allowed specific rights to what data
		+ Confidentiality: What can be access
		  1. The credit card number you used on-line
		  2. your phone number
		  3. your eMail address
		  4. residential address
		  5. shopping history (what and where)
		  6. current location
		  7. health history
		  8. browser history
		  9. texting history
		  10. DNA
		  11. Password
	    + Confidentiality: Who can access
		  1. Family
		  2. real-world friends
		  3. people on social media
		  4. retailers
		  5. employwer
		  6. political party
		  7. police
		  8. federal government
		+ Confidentiality: Data in Transit
		  - Symmetric-key cryptography
			- Believed to provide strong security
			- Both sender and reciever must know secret key
			- /Key distribution problem/: how to share the secret key
		  - Asymmetric-key cryptography (public-key)
		+ Confidentiality: Data at rest
		  - Hash values are an example of a one-way function (easy one way, hard the other)
		  - Hash values are stored, not the actual passwords
		  - Cookies Example
			- Cookies store state information in clients (browsers
** CS310
*** Lecture
**** Review
**** Predicates
***** WHERE
		Returns three options
		1. TRUE
		2. FALSE
		3. UNKNOWN
***** Logical Operators
	  + AND
		ex: 
#+BEGIN_SRC sql
SELECT * FROM Student
WHERE FIRSTNAME = 'Hope' OR LastName = 'Geller';
#+END_SRC
	  + OR
	  + NOT
***** Compariosn Operators
	  Used to check for comparative sameness between two expressions
	  (=,!=, <, >,<=,>=, LIKE)
***** LIKE
	   - The 'wildcard' in SQL is '%'
	   - Different than 'equality'. Checks for partial equality
	   - ex:
#+BEGIN_SRC sql
SELECT * FROM Student WHERE LastName LIKE 'S%';
#+END_SRC
***** ORDER BY
	  - orders information by (date, name, id, etc...)
#+BEGIN_SRC sql
SELECT *
FROM Class
ORDER BY Name ASC;	 
-- ORDER BY MaximumStudents, Name
-- ASC means ascending
-- DESC means descending
#+END_SRC
**** ALTER TABLE & FOREIGN KEY
***** Syntax
#+BEGIN_SRC sql
ALTER TABLE <tablename> ADD FOREIGN KEY (<columnname>)
REFERENCES <anothertable> (<columnname>)
#+END_SRC
**** Scalar Function
A function that takes zero or more parameters. It evaluates inputs and reutrns a result
 - Will return one value per record that it evaluates
 - Never changes stored data itself
 - Can be found in SELECT,INSERT, UPDATE,and DELETE queries

examples: CONCAT DATE_ADD LENGTH SUBSTRING NOW()

AS: creates an alias
SELECT CONCAT(FirstName, ' ', LastName) AS FullName, BirthDate
FROM Student
**** Procedure
***** Notes
	 - A database structure or construct that contains one or more sql queries
	 - Unlike functions, procedures can change data
***** Benefits
	  - Avoid duplicating database code
	  - Easier to tweak performance or behaviour in the database
	  - Can provide more security by limiting user access
	  - Encourages encapsulation
***** Examples
		
#+BEGIN_SRC sql
Delimiter $$
Create Procedure GetShortNameStudents()
BEGIN
	SELECT FirstName, LastName
	FROM Student
	WHERE LENGTH(FirstName) <= 5;
END;
$$

/*
	Use with:
CALL GetShortNameStudents();
*/

-- Another example
Delimiter $$
-- here I defined an input variable maxLength of type INT
Create Procedure GetSHortNameStudents2(IN maxLength INT)
BEGIN
	SELECT FirstName, LastName
	FROM Student
	WHERE LENGTH(FirstName) <= 5;
END;
$$
/*
	Use with:
CALL GetShortNameStudents2(6);
*/
#+END_SRC
**** Joining Tables
***** JOIN clause
	  - allows you to connect different sets of data
	  - you can have more than one JOIN clause and connect multiple sets together
	  - you can use LEFT or RIGHT joins, (INNER is an optional keyword and is
		default if no other keywords are present)
	  - Joining tables is often accomplished using a foreign key column that connects 
		to a primary key column in another table
	  - To connect Key columns you will use the ON clause after the JOIN clause
**** Updating a database

*** Assignments
**** Final Project
	 I can start the final project now
**** Homwk 3
	 
#+BEGIN_SRC python
def hello():
	print("Hello World")

hello()
#+END_SRC

#+BEGIN_SRC python
def hello():
	return "Hello World"
print(hello())
#+END_SRC

#+RESULTS:
: None
