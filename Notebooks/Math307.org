#+TITLE: Sage work for Math307 - Quizzes and exams
#+AUTHOR: Justin Johnson

#+NAME: RSA Functions
#+HEADER: :tangle ./src/sage/rsa.sage
#+BEGIN_SRC sage

# Global Variables
_p=0 # prime factor
_q=0 # prime factor
_n=0 # rsa modulos
_phi=0 # euler's totient for p and q
_e=0		# encryption exponent
_t=0		# private key
_M=""	# message
_E=""	# ciphertext

# ASCII PAD METHODS
# BEGIN
# Pads an iterable object into an integer with specifications
def ASCIIPad(Message):
    K = (map(ord,reversed(Message)));
    le= len(K);
    x = [100+K[i] for i in range(le)];
    x = ZZ(x,1000);
    return(x);
	
# Converts padded integer into string message
def ASCIIDepad(Number):
    n = Number.ndigits() % 3;
    if (n > 0):
        print("This is not a padded ASCII string\n");
    else:
        L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
        N = "";
        for i in range(Number.ndigits()/3):
            N = chr(L[i]) + N;
	return(N);

def isASCIIPadded(Number):
    N = ""
    n = Number.ndigits() % 3;
    if (n > 0):
        return False;
    L = [((Number - (Number % (1000^i)))/1000^i)%1000 - 100 for i in range(Number.ndigits()/3)];
    for i in range(Number.ndigits()/3):
        if L[i] < 0:
            return False
        if L[i] > 255:
            return False
    return True
# END
	
# RSA METHODS
# BEGIN
comment="""
Key Generation
 1. Choose two primes p,q and compute:
    n=p*q
    phi(n)=(p-1)*(q-1)
 2. Choose a 'random' number t such taht gcd(x,phi(n))=1
 3. Compute e=t^-1 mod phi(n) (t=e^-1 mod phi(n))
	
Public Key:		(n,e)
Private Key:	(t, phi(n))

*RSA ENCRYPTION*
E=M^e mod n
E=ciphertext of M

*RSA DECRYPTION*
M=E^t mod n

*MISC*
e=t^{-1} mod phi(n)
t=e^{-1} mod phi(n)
e is public
phi(n) is private
"""
	
comment="""
1. Choose two primes p,q and compute:
    n=p*q
    phi(n)=(p-1)*(q-1)
 2. Choose a 'random' number t such taht gcd(x,phi(n))=1
 3. Compute e=t^-1 mod phi(n) (t=e^-1 mod phi(n))
"""
# Public Key:		(n,e)
# Private Key:	(t, phi(n))
def createKeys(p,q):
	global _p
	_p=p
	global _q
	_q=q
	global _n
	_n=p*q
	global _phi
	_phi=(_p-1)*(_q-1)
	global _e
	_e=17
	while gcd(_phi,_e)!=1: _e+=1
	print("Public Key Generated ({},{})".format(_n,_e))
	global _t
	_t=inverse_mod(_e,_phi)
	print("Private Key Generated ({},{})".format(_t,_phi))

def resetKeys():
	global _p
	_p=0 # prime factor
	global _q
	_q=0 # prime factor
	global _n
	_n=0 # rsa modulos
	global _phi
	_phi=0 # euler's totient for p and q
	global _e
	_e=0		# encryption exponent
	global _t
	_t=0		# private key
	global _M
	_M=""	# message
	global _E
	_E=""	# ciphertext
	print("Public/Private Key values have been reset")
	
# Encrypts message using E = M^e mod n
def rsaencrypt(Message, encrexp, encrmod):
    A = ASCIIPad(Message);
    E = power_mod(A,encrexp,encrmod);
    return(E);

# Decrypts message using M = E^t mod n
def rsadecryptS(encr,decrexp,encrmod):
    D = power_mod(encr,decrexp,encrmod);
    N = ASCIIDepad(D);
    return(N);
	
# Decrypts message using M = E^t mod n
def rsadecrypt(encr,decrexp,encrmod):
    return power_mod(encr,decrexp,encrmod);
comment="""
Define ownership of an RSA Key
		1. The key owner chooses two prime numbers, /p/ and /q/
		2. The key owner compute ~n=p*q~ and ~phi(n)=(p-1)*(q-1)~
		3. The key owner chooses an /e/ with ~gcd(e/phi(n))=1~
		   1. Compute ~e=t^-1 mod phi(n)~
		4. The key owner computes ~t=1/e mod phi(n)~
		
		The public signature key is ~(n,e)~ 
		The private signature key is ~t~

Verify Ownership
		- ~S=M^t mod n~
		  - S is a signature on M
		- ~k=S^e mod n~
		- If k=M, then the signature is valid
"""

# Param
# 	M - (M)essage
# 	t - priva(t)e key
# 	n - rsa modulos
def sign(M,t,n):
	S=power_mod(M,t,n)
	M
	print(power_mod(S,_e,n))
	return S

# Param
#     M - (M)essage
#     S - Signature on M
# 	n - rsa modulos
# 	e - (e)ncryption exponent
# FROM LECTURE NOTES: "the challenger computes S^e mod n to see if the answe    r is M"
def verifySignature(M,S,e,n):
	return M==power_mod(S,e,n)
# END
	
# RSA Attack Methods
# BEGIN
##############################################################################################
# isquare detectes weither a number is a perfect square or not                               #
##############################################################################################
def isquare (n):
    if isqrt(n) ** 2 == n:
        return(True)
    return(False)

##############################################################################################
# isqrt takes in an integer as input and produces the floor of the square root of the number#
##############################################################################################
def isqrt(n):
    return int(floor(sqrt(n)))

##############################################################################################
# usqrt takes in a number and produces the celing of the square root of the number           #
##############################################################################################
def usqrt (n):
    ur = isqrt(n)
    if ur ** 2 < n:
        ur = ur + 1
    return(ur)

##############################################################################################
# OneLine will take in a composite nubmer and a round limit and attempt to compute one of the# 
#prime factors. If unable the function will print out that no factors have been found        #
##############################################################################################
def OneLine (n, iter):
    for x in range(1, iter + 1):
		sq = usqrt(x * n)
		y = sq ** 2 % n
		if isquare(y) == True:
			t = isqrt(y)
			u = gcd(n, sq - t)
			print("Factor found in round {0} rounds".format(x))
			return(u)
		print("No factors found")

########################################################################################
# The function takes in the requested inputs and computes a decryption key             #
# If there are not enough digits in the input the function will tell you so            #
########################################################################################

def partial (R, s, partd):
    m = 1000
    E = m.powermod(s,R)#&^(m, s) % R
    for k in range(1, s + 1):
        Dk = math.floor((k * (R - 2 * isqrt(R) + 1) + 1) / s)
        l=(partd).ndigits()
        Dk=Dk-(Dk % 10^l)+partd
        mm = E.powermod(Dk,R)#E&^Dk mod R:
        if m == mm:
            return(Dk)
    print("not enough digits to discover d")
	
# Initial Segment attack
def ISAttack (R):
    n = R.ndigits()
    #n = len(R)
    for j in range(1, n + 1):
        x=(R-(R % 10^j))/10^j
        p = gcd(x, R)
        if ((1 < p)and (p<R)):
            return(p)
    print "nonefound"

# Fermat Factoring Method
# Used if p and q have a small difference
def FermatAttack (n, rounds):
    st = usqrt(n)
    for x in range(st, st + rounds + 1):
        #print (x-st)
        sq = x ** 2 - n
        y = isqrt(sq)
        if y ** 2 == sq:
            print "Factor found in round {0}".format(x-st+1)
            return(x + y)
    return "No factor found in {0} rounds".format(rounds)
# END

showExamples=False
if showExamples:
	print("Show Regular Key Generation")
	p=next_prime(32848237498234982374293)
	q=next_prime(230572130857128375128375092183750921730523170398570921837509127350981027)
	createKeys(p,q)
	resetKeys()
	
	print("\nShow how to sign and verify a message")
	M="Hello World"
	M=ASCIIPad(M)
	p=next_prime(123213123239875983528972359825398721)
	q=next_prime(1212312837129837982732198125125125)
	createKeys(p,q)
	S=sign(M,_t,_n)
	if verifySignature(M,S,_e,_n): print("Valid Signature!")
	else: print("Invalid Signature!")
	print("{} is a signature on {}".format(S, M))
	resetKeys()

	print("\nShow Fermat Attack Method")
	p=next_prime(2141726497126947126496128946182964981264987164987126489712694871269487196)
	q=next_prime(2141726497126947126496128946182964981264987164987126489712312312321312311)
	createKeys(p,q)
	_p=FermatAttack(_n,100)
	if not isinstance(_p, str): 
		_q=_n/_p
		if (_p*_q)==_n: print("Success")
	else:
		print("Failed")
	resetKeys()
	
# Encrypted then signed OR signed then Encrypted
E1=192673410575232178904649776915190700998989853537815830553230611421742385992522416989509275862058211339709950929
E2=11086722953882983852431944511576952516550372827816915921973944718976810268666675210351469628970964240272091459974947601880432783056689928327962090547865754927288993076429
E3=1834496602541743526158189555689903156371898111774868041164889421551770983263334034443653217840819146984865628720631961622548297373876065576

#key=(0,1,2  ,3)
#key=(n,e,phi,t)
keyA=(76658177305027745952631719056705996813842536289251500683261184543556255161304991640490427342739196690985988361653741113103098879695402379917606571643825715761882994534703,324382479328749283092183091832019840198400001)
keyB=(305305799846472299868002515458930157177903223108162710252913053729390747860737704417309741537399438511250989442729880781658025831833386498939,349874928174912837921492180000001)
keyD=(61823435968160437417469491157734955693190192084429162238180686630269127581382430522764865425365025843237298546732978005917453969903,3843243287434824441111878911001,61823435968160437417469491157734955693190192084429162238180686622392533899929241536658509172593305085911230229647058820648322486488)
t=inverse_mod(keyD[1],keyD[2])
keyD+=(t,)

#Alice Signs
E=power_mod(E2,keyA[1],keyA[0])
M=rsadecryptS(E,keyD[3],keyD[0])
print("ALICE: {}".format(M))

#ALICE
E=power_mod(E1,keyA[1],keyA[0])
#+END_SRC

#+RESULTS: RSA Functions
: ALICE: Who will win the World Series?
: 'No factor found in 10000 rounds'
